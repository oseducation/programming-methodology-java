# MagicMatrix

პრობლემა: 
```
მატრიცას ეწოდება მაგიური თუკი ის კვადრატულია(n x n-ზე) და მასში არის ყველა
რიცხვი 1-დან n^2-ის ჩათვლით. თქვენი მიზანია დაწეროთ magicMatrix მეთოდი
რომელიც შეამოწმებს არის თუ არა მატრიცა მაგიური და თუკი მაგიურია მაშინ
დააბრუნებს true-ს თუ არა მაშინ false-ს.

```



## პირობის გააზრება:

ამ ამოცანის პირობაში ყურადღება უნდა მივაქციოთ ორ მნიშვნელოვან პირობას

* პირველ რიგში მატრიცა უნდა იყოს კვადრატული(უნდა შევამოწმოთ არის, თუ არა ის კვადარატული).
* თუ ის კვადრატულია, მაშინ უნდა შევამოწმოთ სწორად არის თუ არა ის შევსებული.



## პრობლემის გადაჭრის გზა:

* პირველ რიგში გავაკეთოთ მეთოდი `private boolean magicMatrix(int[][] inp)` , რომელიც დააბრუნებს `true` - ს 
ან `false` -ს (იმისდა მიხედვით, არის თუ არა ჩვენი მატრიცა კვადრატული).

* როგორც ზემოთ მოგახსენეთ, ჯერ უნდა შევამოწმოთ, არის თუ არა ეს მატრიცა კვადრატული შემდეგი შემოწმებით:

```java
if (inp.length == 0 || inp.length != inp[0].length) {
    return false;		
}
```
-სადაც, `inp.length` არის row -ს სიგრძე, ხოლო `inp[0].length` collumn-ის სიგრძე.

შესაბამისად, ამ პირობის გაგება`inp.length != inp[0].length` არ უნდა იყოს რთული(ამით ვამოწმებთ, არის თუ არა row - ს სიგრძე collumn - ის სიგრძის ტოლი).
ამ შემთხვევაში ყურადღება უნდა მივაქციოთ შემოწმებას: `inp.length == 0`. თუ ამ პირობას არ შევამოწმებთ, მაშინ `inp.length != inp[0].length` დაიქრაშება, 
რადგან ინფორმაციის წაკითხვას ვცდილობთ იქიდან, რაც არ არის.

* დავუშვათ, row - ს სიგრძე collumn - ის სიგრძის ტოლია. მაშ ისღა დაგვრჩენია შევამოწმოთ, სწორად არის შევსებული თუ არა ეს მატრიცი.



## სწორად არის თუ არა მატრიცა შევსებული:

* row == collumn

* გადავუყვეთ მატრიცის თითოეულ ელემენტს (ანუ ჯერ შევამოწმოთ პირველი row - ს ელემენტები, შემდეგ მეორესი და აშ) და ვნახოთ სწორი ინფორმაცია წერია, თუ არა:

```java
for (int r = 0; r < inp.length; r++) {
    	for (int c = 0; c < inp[0].length; c++) {
		int rightNum = r * inp.length + c + 1;
		if (inp[r][c] != rightNum) {
			return false;
		}
	}
}
```
`int rightNum` გვიჩვენებს თუ რა რიცხვი უნდა ეწეროს კონკრეტულ ადგილას მატრიცაში, იმ შემთხვევაში თუ ის magic მატრიცაა.

```java
int rightNum = r * inp.length + c + 1;
```
მოდი ეს ნაწილი უფრო დეტალურად გავიაროთ. დავუშვათ გვაქვს 3 x 3 მატრიცა. პირველ რიგში ჩვენი მეთოდი შევა პირველ `for` ციკლში და შეამოწმებს პირველ row - ს 
ელემენტებს:

ვთ: `inp[0][0] = 1; inp[0][1] = 2; inp[0][2] = 3;`
როცა, c == 0, rightNum == 1. როცა, c == 1, rightNum == 2. როცა, c == 2, rightNum == 3;
შემდეგ სვეტების შემთხვევაში rightNum -ს კიდევ ემატება წინა row - ების ელემენტებს შორის უდიდესი.

`inp[r][c] != rightNum` - თუ კონკრეტულ ადგილას არასწორი რიცხვი წერია უნდა დავაბრუნოთ `false`.

* იმ შემთხვევაში, თუ ჩვენ მეთოდის ბოლოში გავედით, ანუ ყველაფერი კარგადაა და უნდა დავაბრუნოთ `true`.


## შესაძლო ხარვეზები:

* თუ არ შევამოწმებთ მატრიცის length, შესაძლოა დაიქრაშოს ჩვენი პროგრამა, რადგან collumn - ის სიგრძის გაგებისას(როცა მატრიცის length == 0), ჩვენი პროგრამა ეცდება 
წაიკითხოს ინფორმაცია არარსებული რაღაციდან.

* შემდეგი ძალიან მნიშვნელო ხარვეზი შეილება იყოს `int rightNum` ის დათვლისას (აუცილებლად სწორად უნდა იქნეს გამოთვლილი).

*  `r * inp.length` ამის მაგივრად შეგვეძლო დაგვეწერა წინა row - ს ბოლო ელემენტის მნიშვნელობა, თუმცა მაშინ პირველ row ში ჩვენი პროგრამა დაიქრაშებოდა, ამიტომ ესეც უნდა 
გაგვეთვალისწინებინა. 

