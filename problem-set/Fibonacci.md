# Fibonacci

პრობლემა:
```
მოხმარებელს შეყავს მთელი რიცხვი n, პროგრამამ უნდა დაბეჭდოს ფიბონაჩის მიმდევრობის მე n წევრი.
```

### პრობლემის გადაჭრის გზა
ფიბონაჩის მიმდევრობაში ყოველი ახალი წევრი წინა 2-ის ჯამის ტოლია, ამიტომ ყოველი ახალი რიცხვის გენერაციის შემდგომ შევინახოთ ბოლო 2 რიცხვი და მათი დახმარებით გამოვთვალოთ ყოველი მომდევნო. გავიმეოროთ ეს ქმედება n-2 ჯერ (რადგან მიმდევრობის პირველი 2 წევრი ცნობილია).

### სიღრმისეული განხილვა
კონსოლიდან წავიკითხოთ n.
თუ n არადადებითია კონსოლში გამოვიტანოთ შესაბამისი შეტყობინება (მაგალითად: მიმდევრობას ვერ ეყოლება -5-ე წევრი).
როცა გვეკითხებიან პირველი ელემენტის მნიშვნელობას, გენერაციის გარეშე დავაბრუნოთ მიმდევრობის საწყისი წევრი, ანუ 0.
ინდექსების მიხედვით ფიბონაჩის მიმდევრობა ჩაიწერება, როგორც fibonacci[n] = fibonacci[n-2] + fibonacci[n-1]. აღვწეროთ ცვლადები, სადაც შევინახავთ fibonacci[n-2]-ს (2-ით წინა წევრს) და fibonacci[n-1]-ს (წინა წევრს):
>       int firstNum = 0;
>       int secondNum = 1;
გვაქვს მიმდევრობის პირველი და მეორე წევრი, შესაბამისად გენერაცია დაიწყება მესამე წევრიდან და გაგრძელდება n-ის ჩათვლით:
>       for(int i = 3; i <= n; i++){ ... }
ყოველ ჯერზე ახალი წევრი newNumber გავუტოლოთ წინა 2-ის firstNum-ისა და secondNum-ის ჯამს. ამის შემდეგ საჭიროა მონაცემების გაახლება. secondNum-მა უნდა გადაინაცვლოს firstNum-ში, რადგან მომდევნო წევრისთვის იგი არა წინა, არამედ უკვე 2-ით წინა ელემენტია, ხოლო დაგენერირებული ელემენტი newNumber ჩაანაცვლებს secondNum-ს, რადგან იგი მომდევნო ელემენტისთვის წინა ელემენტი ხდება. საბოლოოდ გამოდის, რომ ბოლო newNumber გენერაცია შენახულია secondNum-ში, ამიტომ კონსოლში გამოვიტანთ secondNum-ის მნიშვნელობას.
ეს ყველაფერი განვიხილოთ მაგალითზე:

* firstNum = 0 (1-ლი წევრი), secondNum = 1 (მე-2 წევრი);
* newNumber = firstNum + secondNum = 0 + 1 = 1 (მე-3 წევრი);
* იმისთვის რომ დავაგენერიროთ მე-4 წევრი საჭიროა მე-2-სა და მე-3 წევრების ჯამი, ამრიგად უნდა გავაახლოთ firstNum-ისა და secondNum-ის მონაცემები.
* firstNum = secondNum = 1 (მე-2 წევრი), secondNum = newNumber =  1 (მე-3 წევრი);
* newNumber = firstNum + secondNum = 1 + 1 = 2 (მე-4 წევრი);
> ამოვწეროთ თითოეული: 0, 1, 1, 2... როგორც ვხედავთ მიღებული მიმდევრობა ფიბონაჩის მიმდევრობაა.

### შესაძლო კითხვა
* ცალკე შემთხვევად განვიხილეთ, როცა გვეკითხებიან პირველ წევრს, რატომ არ განვიხილეთ საწყისივე მეორე წევრი ცალკე?
როცა n = 2, for ციკლი არ ამუშავდება, რადგან i = 3 და განვიხილავთ n-ზე ნაკლებ ან ტოლ i-ებს, ხოლო 3 n-ზე მეტია, შესაბამისად არ შეიცვლება secondNum-ის მნიშვნელობა. ე.ი კოდი დაბეჭდავს secondNum-ის თავდაპირველ, ანუ სწორ მნიშვნელობას.

### შესაძლო ხარვეზები
* პირველ რიგში, რაც შეიძლება შეგეშალოთ, არის პირველი წევრის ცალკე შემთხვევად არ განხილვა.
მისი განხილვა საჭიროა, რადგან ფიბონაჩის პირველი 2 წევრი ყოველთვისაა მოცემული, არ საჭიროებს გენერაციას, ამიტომ საჭიროა პირდაპირ გამზადებული მნიშვნელობის დაბეჭვდა. იმის გასაგებად, თუ რატომ არ საჭიროებს მეორე წევრის შემთხვევა ცალკე განხილვას, იხილეთ **შესაძლო კითხვა**.
* არადადებით ინდექსზე მდგომი ელემენტის პოვნა შეუძლებელია.
არ არსებობს მე-0 /მენულე/ ან -მე-7 /მინუს მეშვიდე/ ელემენტი მიმდევრობაში. ამიტომ ამ შემთხვევის განხილვაც ცალკე საჭიროა.