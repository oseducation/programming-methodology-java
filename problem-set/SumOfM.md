# SumOfM

პრობლემა:
```
კონსოლიდან შეგვყავს რიცხვი m და n, შემდეგ n ცალი რიცხვი. პროგრამამ უნდა იპოვოს შეყვანილი რიცხვებიდან წყვილი რომელთა ჯამი არის m.
```

## პრობლემის გადაჭრის გზები
პრობლემის გადაჭრის მრავალი გზა არსებობს, ზოგი უფრო ოპტიმიზირებული, ვიდრე სხვები. განვიხილოთ ორი მათგანი:
* nested for-ლუპები. ამ ამოხსნაში ჯერ ავირჩევთ ერთ რიცხვს, ხოლო მერე, შიდა ლუპში, გადავყვებით ყველა დანარჩენს და ვნახავთ ემთხვევა თუ არა მათი ჯამი შემოტანილ რიცხვს
* დავასორტიროთ შემოტანილი მასივი და შემდგომ ყოველი ელემენტისთვის მოვძებნოთ ჯამს - ეს ელემენტი binary searchით.

---

### მონაცემების ჩაწერა
წავიკითხოთ ორივე ინტეჯერი (m და n), ხოლო შემდგომ, შევქმნათ n ზომის მასივი და for ლუპით წავიკითხოთ n ცალი ელემენტი.
ინტეჯერების წაკითხვა შეგვიძლია readInt() მეთოდით.

მივიღებთ მსგავს კოდს:
```java
int[] arr = new int[size];
for(int i = 0; i < size; i++) {
    arr[i] = readInt("? ");
}
return arr;
```

### მასივის სორტირება
მასივის დასასორტირებლად შეგვიძლია ინტერნეტში მოვძებნოთ ალგორითმები, ან უბრალოდ გამოვიყენოთ Arrays.sort(int[] arr)

რაღაც ასე:
```java
int[] arr;
///
///
Arrays.sort(arr);
```

### ელემენტების ძებნა
ელემენტების მოსაძებნად შეგვიძლია დავწეროთ binary search ალგორითმი, რომელიც O(logn)ში მუშაობს.
ეს მეთოდი დაგვიბრუნებს true-ს თუ ნახა ელემენტი, და false თუ - ვერა.

შეიძლება გაიფიქროთ რატო ინდექსი არა და ეს იმიტომაა, რომ არ გვჭირდება წვდომა იმ რიცხვთან, უბრალოდ გვჭირდება იმის ცოდნა, არსებობს თუ არა ის.
მეთოდი იქნება ასეთი:
```java
boolean contains(int[] arr, int l, int r, int x) {
    if (r >= l) {
        int mid = l + (r - l) / 2;
            
        if (arr[mid] == x)
            return true;
                
        if (arr[mid] > x)
            return contains(arr, l, mid - 1, x);
                
        return contains(arr, mid + 1, r, x);
    }
    return false;
}
```

---

### ნაკლებად ოპტიმალური ხერხი
ნაკლებად ოპტიმალური ხერხი იწყება იმავენაირად, თუმცა განსხვავება არის ელემენტების ძებნაში.
ამ ხერხში გადავუყვებით ყველა ელემენტს, და ყველა ელემენტისთვის ვნახავთ არსებობს თუ არა ისეთი, რომლის დამატებისას ვიღებთ საჭირო ჯამს

ძებნის კოდი:
```java
int[] arr;
int sum;

///

for(int i = 0; i < arr.length; i++) {
    for(int j = i; j < arr.length; j++) {
        if(arr[i] + arr[j] == sum) {
            println(arr[i] + " + " + arr[j] + " equals " + sum);
            return;
        }
    }
}
println("Sorry, no pair found");
```
ეს ალგორითმი იმუშავებს O(n\*n)-დროში, სადაც n არის ელემენტების რაოდენობა
