# FillRaw

პრობლემა:
```
კარელი დგას 1x1 უჯრაზე, შეავსებინეთ მას პირველი ქუჩა ბრილიანტებით. ანუ პირველი ქუჩის ყველა უჯრაზე უნდა იდოს ზუსტად ერთი ბრილიანტი. ჩათვალეთ რომ საწყის სამყაროში ბრილიანტები არსად არ დევს.
```



## პრობლემის გადაჭრის გზა
პირველ რიგში ჩვენი პრობლემა დავყოთ ორ ნაწილად
* კარელმა უნდა გაიაროს მთლიანი ქუჩა
* სიარულთან ერთად, კარელმა პარალელურად უნდა განათავსოს ბრილიანტები ქუჩაზე

---

### მთლიანი ქუჩის გავლის პრობლემას გადავჭრით შემდეგი საშაულებით
1. გამოვიყენოთ კარელისათვის ცნობილი `frontIsClear()` მეთოდი.
2. გამოვიყენოთ `while` ციკლი.
3. წინაღობის შემოწმების შემდგომ, განვახორციელოთ 1 უჯრით წინ გადანაცვლება `move()` მეთოდის საშუალებით, რათა შევძლოთ მთლიანი ქუჩის გავლა.


შესაბამისად, მივიღებთ კოდს:
```java
while(frontIsClear()) {
    move();
}
```

> *როდესაც კარელის წინ აღმოჩნდება კედელი, `frontIsClear()` მეთოდი `while` ციკლს შეატყობინებს, რომ კარელის წინ დაბრკოლებაა და კარელი შეწყეტს სვლას (ციკლი დასრულდება).*

---

### სიარულის პარალელურად, ბრილიანტების განთავსება ქუჩაზე
ახლა, როდესაც კარელი წარმატებით გადის ქუჩას, მნიშვნელოვანია ბრილინატების განთავსება, რომელსაც `putBeeper()` მეთოდის საშუალებით გავაკეთებთ. მისი `while` ციკლში მოთავსებით კოდი მიიღებს შემდეგ სახეს
```java
while(frontIsClear()) {
    putBeeper();
    move();
}
```
ამ ეტაპისთვის გვგონია, რომ პრობლემა გადაჭრილია და არანაირ მოდიფიკაციას არ საჭიროებს, თუმცა კოდის წარმატებით გაშვების შემდგომ მივიღებთ სამყაროს, სადაც კარელმა წარმატებით შეძლო მისი ქუჩის უჯრებზე მხოლოდ 1 ბრილიანტის განთავსება, **გარდა 1 უჯრისა.**

ეს უჯრა, სწორედ ისაა, რომელზედაც იგი მუშაობის დასასრულს იმყოფება. მოდით, განვიხილოთ თუ რას შეიძლებოდა გამოეწვია მსგავსი სახის პრობლემა.
* ამ შეცდომას პროგრამირებაში [Off-By-One Error](https://stackoverflow.com/questions/2939869/what-is-an-off-by-one-error-and-how-do-i-fix-it)-ად მოიხსენიებენ და თავისი სახელიდან გამომდინარე მივხვდებით, რომ შეცდომა ძირითადად **იტერირების** დროს შეიძლება წარმოიშვას.
* განვიხილოთ კარელის შემთხვევა (სამყარო 10x10-ზე)
    * კარელი დგას მე-9 უჯრაზე.
    * დავდეთ ბრილიანტი.
    * გამოვიძახეთ `move()` მეთოდი და გადავინაცვლეთ მე-10 უჯრაზე.
    * მე-10 უჯრაზე გადასვლის შემდგომ კარელი ამოწმებს, აქვს თუ არა მას წინაღობა. იგი იძახებს`frontIsClear()` მეთოდს, რაზეც იგი იღებს პასუხს, რომ მის წინ მდებარეობს კედელი. შესაბამისად, კარელი ასრულებს `while` ციკლს და ვეღარ ახერხებს `putBeeper()` მეთოდის გამოძახებას.

![Image Of Karel Standing on 10th Box](/problem-set/images/XQRF1oc.png)

ამ ყველაფრის შემდგომ, პრობლემის გადასაჭრელად, დაგვჭირდება `putBeeper()` მეთოდის ჩამატება ჩვენს კოდში:
```java
while(frontIsClear()) {
    putBeeper();
    move();
}
// დებს ბრილიანტს, ბოლო უჯრაზე
putBeeper();
```
---

## რატომ იმუშავებს კოდი ნებისმიერი სამყაროს ზომისათვის?
* განვიხილოთ სამყარო, რომლის სიგრძეც 1-ის ტოლია (სიმაღლეს მნიშვნელობა არ აქვს, ვინაიდან კარელი მოძრაობს მარცხნიდან მარჯვნივ, მხოლოდ).
    * ჩვენს მიერ დაწერილი კოდი, პირველ რიგში შეამოწმებს, არის თუ არა კარელის წინ კედელი.
    * `frontIsClear()` მეთოდი დააბრუნებს პასუხს, რომ კარელს გზა დაბლოკილი აქვს და ვერ შეძლებს წინ წასვლას, შესაბამისად კარელი გამოტოვებს `while` ციკლს
    * კარელი გადაინაცვლებს `while` ციკლის შემდგომ ბრძანებაზე და დახვდება `putBeeper()` მეთოდი, რაც უზრუნველყოფს ბრილიანტის წარმატებით დადებას სამყაროში. შესაბამისად, ჩვენი პრობლემაც გადაჭრილია და კარელი იდგება ქუჩაზე, რომლის ყველა უჯრაზე მხოლოდ 1 ბრილიანტი დევს
    
    ![Karel in 1x10 World](/problem-set/images/RwZB99V.png)

* ნებისმიერი სხვა სამყაროსთვის, რომლის სიგრძეც > 1, ზუსტად იგივე ლოგიკით იმუშავებს, როგორც ზემოთხსენებული 10x10 სამყაროზე იმიტომ, რომ კარელი ამოწმებს წინ არსებულ დაბრკოლებას და მხოლოდ ამის შემდგომ იღებს გადაწყვეტილებას, გააგრძელოს თუ დაასრულოს სვლა.

---

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
პირველ რიგში, მინდა მოგილოცოთ პროგრამის წარმატებით დასრულება და იმპლემენტაცია, თუმცა არსებობს 2 დეტალი, რისი გათვალისწინებაც საკმაოდ მნიშვნელოვანია ამ ამოცანის გადაჭრისას

1. გასათვალისწინებელია ზემოთ ნახსენები [Off-By-One Error](https://stackoverflow.com/questions/2939869/what-is-an-off-by-one-error-and-how-do-i-fix-it)
2. ასევე, საინტერესოა, რა მოხდება თუ `while` ციკლის ტანში ადგილებს გავუცვლით `move()`-სა და `putBeeper()` მეთოდებს. ერთი შეხედვით თითქოს ისევ სწორად უნდა იმუშაოს პროგრამამ, ვინაიდან ჩვენ მხოლოდ 2 ბრძანებას გავუცვალეთ ადგილი.
    1. მივიღებთ კოდს 
        ```java
        while(frontIsClear()) {
            move();
            putBeeper();
        }
        putBeeper();
        ```
    2. თუ კარგად დავაკვირდებით და გავიაზრებთ კოდს, შევამჩნევთ, რომ კარელის ქმედებები შეიცვლება.
        * კოდის გაშვების შემდეგ კარელი ჯერ გადაინაცვლებს მეორე უჯრაზე, ხოლო ამის შემდეგ დადებს ბრილიანტს.
        * თავისთავად ჩვენს კოდში წარმოიშვა ხარვეზი, რაც მოიაზრებს შემდეგს: კარელის სამყაროში პირველი უჯრა ყოველთვის ცარიელი დარჩება, ხოლო დამთავრების ადგილას იგივე განათავსებს 2 ბრილინატს.
    
    ![Karel in 1x10 World](/problem-set/images/karel_bug_0.png)

    3. ამ პრობლემას 1 მარტივი გადაჭრის გზა აქვს.
        1. ავიტანოთ `while` ციკლის გარეთ მყოფი `putBeeper()` მეთოდი და გამოვიძახოთ `while` ციკლის გამოძახებამდე.
        2. ახალი კოდი 
            ```java
            putBeeper();
            while(frontIsClear()) {
                move();
                putBeeper();
            }
            ```
