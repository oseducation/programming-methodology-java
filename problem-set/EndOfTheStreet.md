# EndOfTheStreet

ამოცანა:
```
ცარიელ სამყაროში კარელი დგას 1x1 უჯრაზე, გაიყვანეთ იგი პირველი ქუჩის ბოლომდე. გაითვალისწინეთ, რომ სამყაროს ზომა არ იცით. თქვენი პროგრამა უნდა მუშაობდეს ნებისმიერი ზომის სამყაროსათვის.
```

## ამოცანის ამოხსნა
ქუჩის ბოლომდე მისასვლელად გვჭირდება `move` ბრძანების გამოყენება. მას გამოვიყენებთ მანამ, სანამ კარელი ქუჩის დასასრულს, ანუ კედელს არ წააწყდება. ამას კი `frontIsClear` ბრძანებით გავიგებთ. თუკი `frontIsClear` დაგვიბრუნებს `false`-ს ესე იგი კარელი ქუჩის ბოლოშია. ჩვენი პროგრამა უნდა მუშაობდეს სამყაროს ნებისმიერი ზომებისთვის, მისი ზომა კი წინასწარ არ გვეცოდინება, ამიტომაც კარგი იდეაა, თუკი გამოვიყენებთ `while` ციკლს.

შესაბამისად, გვექნება ასეთი კოდი:
```java
while(frontIsClear()) {
    move();
}
```
> *როდესაც კარელი მივა ქუჩის ბოლოში, `frontIsClear()` მეთოდი დაგვიბრუნებს `false`-ს. `while` ციკლი შეწყდება და პროგრამაც დასრულდება.*

## რატომ იმუშავებს ეს ამოხსნა ყველა სამყაროსთვის?
დააკვირდით იმ ფაქტს, რომ ჩვენი კოდი არ იყენებს სამყაროს ზომებს. იგი ემყარება `while` ციკლს და ყოველ სვლაზე ამოწმებს მივიდა თუ არა კარელი კედელთან. თითოეულ სვლაზე კი ერთი ნაბიჯით ვუახლოვდებით ქუჩის ბოლოს. შესაბამისად, ადრე თუ გვიან კარელი მივა დანიშნულების ადგილას და ეს სამყაროს ნებისმიერი სასრული ზომის შემთხვევაში მოხდება.

## რატომ ვიყენებთ `while` ციკლს `for` ციკლის ნაცვლად? ან საერთოდ რა საჭიროა ციკლი?
* `while` ციკლის უპირატესობა `for`-თან შედარებით არის ის, რომ არ არის აუცილებელი წინასწარ ვიცოდეთ ციკლის ნაბიჯების რაოდენობა. უბრალოდ გვაქვს პირობა `frontIsClear()`, რომელიც შეიძლება 5 ნაბიჯის შემდგომ, ან კიდევ 100 ნაბიჯის შემდგომ დაირღვეს. `while` ციკლი ყველა ასეთ შემთხვევაში იმუშავებს.
* ციკლი კი იმიტომ არის საჭირო, რომ ჩვენმა ამოხსნამ ნებისმიერი სამყაროსთვის იმუშავოს. შეიძლება 5 ზომის სამყაროზე 5-ჯერ დაგვეწერა `move` ბრძანება, თუმცა ასეთი კოდი სხვა ზომის სამყაროებში ჩაიჭრებოდა.

## რატომ არ გვაქვს ამ ამოცანაში [Off-By-One Error](https://stackoverflow.com/questions/2939869/what-is-an-off-by-one-error-and-how-do-i-fix-it)?
ამ ამოცანაში კარელის წინ წასვლა ზუსტად იმდენჯერ გვჭირდება, რამდენჯერაც `frontIsClear()` გვიბრუნებს `false`-ს. ამიტომაც, სხვადასხვა ბრძანებების გამოძახებების რაოდენობებს შორის აცდენა არ გვაქვს.