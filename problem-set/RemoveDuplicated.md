# RemoveDuplicated

პრობლემა:
```
დაწერეთ მეთოდი რომელიც გადაცემული ტექსტიდან შლის დუბლირებულ სიმბოლოებს,
ანუ თუ ტექსტიში რომელიმე სიმბოლო მეორდება, უნდა დარჩეს მხოლოდ ყველაზე მარცხენა.
```



## პრობლემის გადაჭრის გზა:
ამოცანის ამოსახსნელად, საჭიროა, 3 ეტაპი:
 *მომხმარებელმა უნდა შემოიტანოს სტრინგი;
 *პროგრამამ უნდა დაგვიბრუნოს მოცემული სტრინგი დუბლირებული სიმბოლოების გარეშე, ოღონდ დატოვოს გამეორებული სიმბოლოს ყველაზე მარცხენა ქარი.
 *პროგრამამ უნდა დაპრინტოს მიღებული სტრინგი კონსოლში.

---

### I.მომხმარებლის მიერ შემოტანილი ინფორმაციის წაკითხვა:
 * მომხმარებელმა კონსოლში უნდა შემოიტანოს სტრინგი str, რასაც ვაკეთებთ readLine() მეთოდის მეშვეობით. იმისათვის, რომ ჩვენს კონსოლის პროგრამას გასაგები ინტერფეისი ჰქონდეს, readLine()-მეთოდს ფრჩხილებში გადავცემთ არგუმენტს, ანუ იმას თუ რა უნდა დაპრინტოს პროგრამამ, ვიდრე მომხმარებელი შემოიყვანს სტრინგს (str-ს). საბოლოოდ მივიღებთ readLine("Enter string: "); სინტაქსს. readLine მეთოდის დაბრუნებულ String მნიშვნელობას ვინახავთ str ცვლადში, შესაბამისად, მივიღეთ კოდი : String str = readLine("Enter string: ");

### II.დუბლირებული ელემენტების ამოშლა:

 * ჩვენი მიზანია, რომ ჩვენს მომხმარებელს დავუბრუნოთ String, რომელშიც არ იქნება დუბლირებული სიმბოლოები, ამის გასაკეთებლად შეგვიძლია, მართლაც, გადმოცემული String-დან ვშალოთ გამეორებული სიმბოლოები, თუმცა გაცილებით მარტივი იქნება, თუკი ახალ ცვლადში (თავდაპირველად ის არის ცარიელი სტრინგი "") ნელ-ნელა დავუმატებთ სიმბოლოებს, ოღონდ, ამავდროულად, შევამოწმებთ არის თუ არა დასამატებელი სიმბოლო უკვე გამოყენებული და იმ შემთხვევაში თუკი არ არის (ანუ დუბლირებული არაა და პირველად შეგვხვდა), მხოლოდ მაშინ დავამატებთ. ამის გასაკეთებლად, ცხადია, დაგვჭირდება ცარიელი სტრინგი და ასევე იმ სიმბოლოთა კოლექცია, რომელიც უკვე შეგვხვდა, რომ შევამოწმოთ უნდა დავუმატოთ თუ არა ჩვენს ახალ სტრინგს ეს სიმბოლო. ამიტომ გვექნება ცვლადები :
```java
List<Character> usedChars = new ArrayList<Character>();
String res = "";
```

### რატომ Character და არა char? : 

 * დავაკვირდეთ, რომ usedChars არის List - ინტერფეისის ტიპის, რომელსაც თემფლეით არგუმენტი აქვს Character და არა სტანდარტული char. Character არის უბრალოდ კლასი, რომელსაც ერთი field გააჩნია char ტიპის. და მიზეზი, თუ რატომ ვიყენებ Character-ს არის ის, რომ თემფლეით არგუმენტი უნდა იყოს reference type განსხვავებით პრიმიტიული valuetype char ტიპისგან. 


### რატომ List და არა ArrayList? :
 * უნდა ითქვას, რომ ამ კონკრეტული ამოცანისთვის, მნიშვნელობა არ ექნებოდა List-ის მაგივრად ArrayList რომ დაგვეწერა, თუმცა უნდა გავითვალისწინოთ, რომ კოდის გადაკეთება რომ მოგვიწიოს, მისი შეცვლა მარტივად უნდა შეგვეძლოს (რამდენადაც ეს შესაძლებელია) ამიტომ ყოველი ობიექტისთვის უმჯოებისა გამოვიყენოთ მისი ის აბსტრაქცია, რომელიც ფარავს ჩვენს მიერ მოთხოვნილ ფუნქცინოლას, ამ შემთხვევაში ArrayList ის ინტერფეისი გახლავთ List და ვიცით, რომ ყოველი კლასი რომელიც იშვილებს ამ List ინტერფეისს ექნება მისი ფუნქციონალი, ხოლო რადგან ჩვენs კოლექციაში მხოლოდ ელემენტის ჩამატება და ინდექსით ამოღება გვსურს, List ინტერფეისი გვთავაზობს ამ ყველაფერს, ამიტომაც usedChars კოლექცია გავხადეთ List ინტერფეის ტიპის, ამის შემდეგ ჩვენი კოდისთვის არ აქვს მნიშვნელობა ArrayList იქნება usedChars კოლექცია თუ Vector ტიპის, უბრალოდ ჩავანაცვლებთ ჩვენი სასურველი კლასით, რომელიც რეალიზებს List ინტერფეისს და კოდი იმუშავებს სწორად, მეტი ჩანაცვლების გაკეთება არსად არ დაგვჭირდება.

### სიმბოლოების დამატება res ცვლადში:
 * იმისათვის, რომ სიმბოლოები დავამატოთ, უნდა გადავუყვეთ ჩვენს მიერ მოცემულ სტრინგს და სათითაოდ ვამატოთ ყველა სიმბოლო, ოღონდ მხოლოდ და მხოლოდ იმ შემთხვევაში,  თუკი ეს სიმბოლო უკვე არ გამოგვიყენებია, ანუ არ არის დუბლირებული. ამიტომ for-ის ყოველ იტერაციაზე უნდა შევამოწმოთ არის თუ არა ეს სიმბოლო ჩვენს მიერ გამოყენებულ სიმბოლოთა მასივში, რისთვისაც დაგვეხმარება ჩვენი მეთოდი contains

### contains მეთოდი: 
 * ამ მეთოდს გადაეცემა ორი არგუმენტი, List<Character> და char ტიპების. ყურადღება მივაქციოთ, რომ ვიყენებთ ისევ List ინტერფეისის ტიპს და არა რაიმე კონკრეტულ კლასს, რათა აბსტრაქცია შევინარჩუნოთ. მეთოდში გადავუყვებით გადმოცემულ მასივს და ვამოწმებთ ყოველ ელემენტს, ტოლი არის თუ არა იგი გადმოცემული ch ცვლადის და თუ კი, მეთოდი აბრუნებს true-ს და წყვეტს მუშაობას. თუკი for ლუპი დამთავრდა, ესეიგი true არ დაბრუნდა და არცერთი ელემენტი არ იყო ch-ის ტოლი, ამიტომ ვაბრუნებთ false-ს. მივიღეთ შემდეგი კოდი : 
```java
for(int i = 0; i<ls.size();i++) {
	if(ls.get(i) == ch) {
		return true;
	}
}
return false;
```

### სიმბოლოს ჩამატება : 
 * თუკი contains მეთოდმა დააბრუნა false (ამიტომაც გვიწერია ! contains-ის წინ : if(!contains(usedChars,ch)) ), ანუ არ აღმოჩნდა ამჟამინდელი ელემენტი გამოყენებულ სიმბოლოთა სიაში, ე.ი. უნდა დავუმატოთ იგი ჩვენს res ცვლადს, რასაც ვაკეთებთ += ოპერატორის მეშვეობით. და საბოლოოდ არ უნდა დაგვავიწყდეს გამოყენებულ სიმბოლოებში ამ ჩვენი ახალ აღმოჩენილი სიმბოლოს დამატება. ამიტომ მივიღებთ კოდს :
```java
for(int i = 0; i<str.length();i++) {
	char ch = str.charAt(i);
	if(!contains(usedChars,ch)) {
		res+=ch;
		usedChars.add(ch);
	}
}
```
ამის შემდგომ კი უბრალოდ ვაბრუნებთ ჩვენს res ცვლადს.


### III. მიღებული შედეგის დაპრინტვა კონსოლში:
 * კონსოლში მიღებულ შედეგს ვპრინტავთ უბრალოდ println მეთოდით და საბოლოოდ გამოგვდის სინტაქსი : 

```java
println(str);
```

---

### შესაძლო პრობლემა, Character-ის ლისტის მაგივრად String-ების ლისტის გამოყენებისას:
 * ცხადია, რომ შეგვეძლო List<Character> - ის მაგივრად List<String> გამოგვეყენებინა და ამ შემთხვევაში contains მეთოდში, char-ზე შედარებისას მოგვიწევდა ch+"" სინტაქსის გამოყენება, ამიტომ გვექნებოდა :  if(ls.get(i) == ch+"") { ... }, თუმცა ეს კოდი არ იმუშავებდა რადგან String ცვლადები მათი მნიშვნელობებით უნდა შევადაროთ, წინააღმდეგ შემთხვევაში == შეადარებდა მათ ობიექტებს, ამიტომ უნდა გამოვიყენოთ .equals() მეთოდი, ამიტომ იმისათვის, რომ კოდს სწორად ემუშავა უნდა გამოგვეყენებინა 
```java
if(ls.get(i).equals(ch+"")) {...}
```


### ალტერნატიული ამოხსნა : 
 * მოცემული ამოცანის ამოხსნა შეგვეძლო კოლექციებისა და დამხმარე მეთოდის (ჩვენი contains-ის) გამოყენების გარეშეც. ამის შესაძლებლობას გვაძლევს უკვე დაწერილი contains მეთოდი, რომლის გამოძახებაც შეგვიძლია String ტიპის ობიექტზე, ანუ ისევ და ისევ გვექნებოდა String res ცვლადი და როდესაც შემოწმება დაგვჭირდებოდა გამოყენებული არის თუ არა უკვე კონკრეტული სიმბოლო, გამოვიძახებდით res.contains() მეთოდს, ოღონდ ამ მეთოდს პარამეტრად გადაეცემა String ტიპის ობიექტი, ამიტომ მოგვიწევდა დაკასტვა char-ის String-ზე, რასაც ch+""-ის მეშვეობით შევძლებდით, ამიტომ გვექნებოდა შემდეგი კოდი : 
```java
String res = "";
for(int i = 0; i<str.length();i++) {
	char ch = str.charAt(i);
	if(!res.contains(ch+"")) {
		res+=ch;
	}
}
return res;
```