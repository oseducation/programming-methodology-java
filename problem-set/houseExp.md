# house

## პრობლემა:
გრაფიკული პროგრამის გამოყენებით დახატეთ სახლი.

## ამოხსნა:
პირველ რიგში ჩვენი პრობლემა დავყოთ რამდენიმე ნაწილად:
* დავხატოთ კონტური (კედლები)
* დავხატოთ ფანჯრები
* დავხატოთ კარი
* დავხატოთ სახურავი

---

### მომზადება პრობლემის გადასაჭრელად
გრაფიკულ პრობლემებში მუდმივად გვჭირდება მუდმივი ცვლადები, რომლებიც საგნების ზომას(მაგალითად,
 ჩვენს შემთხვევაში, სახლის სიმაღლე, სახურავის სიმაღლე, კედლების ფერი...) განსაზღვრავენ.
ამიტომ, სანამ უშუალოდ კოდის წერას დავიწყებთ, კარგი იქნება თუ ამ მუდმივ ცვლადებს ცალკე აღვწერთ 
private static final ის დახმარებით. ეს საშუალებას მოგვცემს სურვილის შემთხვევაში მარტივად შევცვალოთ განზომილებები.

### ნახატის სიმეტრიულობის პრობლემის გადაჭრის გზა
უკეთესია თუ ნებისმიერი ზომის კანვასზე სახლი სიმეტრიულად, შუაში დაიხატება. ამ პრობლემის
გადაჭრა შესაძლებელია ფუნქციით getWidth() და getHeight(). პირველი აბრუნებს კანვასის სიგანეს (x), 
ხოლო მეორე კი მის სიმაღლეს(y). ამის საშუალებით ჩვენ შეგვიძლია ყოველთვის კანვასის შუაში დავხატოთ სახლის კონტური.
ამ შემთხვევაში მე გადავწვიტე, რომ სახლის სიგანე 8 ნაწილად დავყო, სიმაღლე კი 3-ად. შედეგად, ყოველთვის
სახლის ზომების პროპორციულად შემეძლება ობიექტების ჩამატება. 

> *GRect ობიექტს 4 ცვლადის გადაცემის შემთხვევაში ჯერ გადაეცემა x კოორდინატი, შემდეგ y, ხოლო ამის შემდეგ სიგანე და სიგრძე. 2 ცვლადის გადაცემის შემთხვევაში კი ჯერ სიგანე უნდა გადავცეთ, შემდეგ სიმაღლე და ობიექტი კანვასის სათავეში შეიქმნება.*

> *გავითვალისწინოთ, რომ კანვასში სათავედ ითვლება ზედა მარცხენა კუთხე. x კოორდინატი ითვლება მარცხნიდან მარჯვნივ,ხოლო y ზემოდან ქვემოთ.*

მაგალითად, კედლების კოორდინატების არჩევის შემთხვევაში მივიღებთ კოდს:
```java
  GRect wall = new GRect(getWidth()/2 - WALL_WIDTH/2, getHeight() - WALL_HEIGHT, WALL_WIDTH, WALL_HEIGHT);
}
```

ხოლო ფანჯრის კოორდინატის არჩევის შემთხვევაში შემდეგს:
```java
GRect window1 = new GRect(getWidth() / 2 - 3*WALL_WIDTH/8, getHeight() - 2*WALL_HEIGHT/3, WALL_WIDTH/4, WALL_HEIGHT / 5);
 GRect window2 = new GRect(getWidth() / 2 + WALL_WIDTH/8, getHeight() - 2*WALL_HEIGHT/3, WALL_WIDTH/4, WALL_HEIGHT / 5);
```
> *პირველი ფანჯრის x კოორდინატად ვიღებ სახლის სიგანის პირველ მერვედს, ხოლო მეორე ფანჯრისთვის 5/8-ს. y კოორდინატად კი ორივესთვის სახლის სიმაღლის პირველი მესამედი ავარჩიე*

---

### სახლის კომპონენტების დახატვა
როგორც ზემოთ აღვწერეთ, უკვე მარტივად შეგვიძლია კანვასის ზომების დამოუკიდებლად, სახლის კომპონენტებისთვის 
კოორდინატების არჩევა. კარის x კოორდინატად გადავწვიტე ამეღო სახლის სიგრძის პირველი 3/8-დი. სიგანე იყოს 
სახლის სიგანის მეოთხედი, სიმაღლე კი სახლის სიმაღლის მესამედი. 
მივიღებთ კოდს:
```java
 GRect door = new GRect(getWidth() / 2 - WALL_WIDTH/8, getHeight() - WALL_HEIGHT/3, WALL_WIDTH/4, WALL_HEIGHT/3);
 ```

 სახელურის კოორდინატები კარის კოორდინატებზე დამოკიდებული იყოს. მისი x კოორდინატი კარის ამავე კოორდინატისგან
 დაშორებული იყოს `HANDLE_OFFSET` ზომით, რომელიც დასაწყისში უკვე აღვწერეთ. სახელურის ფორმა ოვალი იყოს და რადიუსიც
 დავაფიქსიროთ `HANDLE_SIZE` ცვლადით.

 მივიღებთ კოდს:
 ```java
  GOval handle = new GOval(getWidth() / 2 - WALL_WIDTH/8 + HANDLE_OFFSET, getHeight() - WALL_HEIGHT/3 + 2*HANDLE_OFFSET,HANDLE_SIZE, HANDLE_SIZE);
```

სახურავის ფორმად სამკუთხედი ავარჩიე. GObjectს ასეთი შვილობილი კლასი არ ჰყავს, ამიტომ GLine-ის საშუალებით
დავხატოთ. GLineს საწყისი და საბოლოო კოორდინატები გადაეცემა, რომელიც სახლის კედლების კოორდინატებზე დამოკიდებული
იქნება. კერძოთ, პირველი ხაზის საწყისი კოორდინატი იქნება ზემოთ აღწერილი GRect-ის საწყისი კოორდინატი, ხოლო
საბოლოო კოორდინატი სიმეტრიულობის გამო კანვასის შუაში იქნება. სახურავის სიმაღლე მუდმივ ცვლადად(ROOF_HEIGHT)
აღვწეროთ. მეორე ხაზის საწყისი კოორდინატი კი პირველი ხაზის საბოლოო კოორდინატი იქნება. მისი საბოლოო Y
კოორდინატი GRect ობიექტისას დაემთხვევა, ხოლო X კი WALL_WIDTHით იქნება დაშორებული.

მივიღებთ კოდს:
```java
GLine line1 = new GLine(getWidth()/2 - WALL_WIDTH/2, getHeight() - WALL_HEIGHT, getWidth() / 2,
        		getHeight() - WALL_HEIGHT - ROOF_HEIGHT);
GLine line2 = new GLine(getWidth() / 2, getHeight() - WALL_HEIGHT - ROOF_HEIGHT, 
        		getWidth()/2 + WALL_WIDTH/2, getHeight() - WALL_HEIGHT);
```

> *არ დაგვავიწყდეს, რომ ობიექტები აღწერის შემდეგ add ფუნქციის საშუალებით უნდა დავამატოთ.*

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
ყველაზე მთავარი შეცდომა, რაც შეიძლება ამ ამოცანაში გამოგვეპაროს არის ფუნქციების შესრულების მიმდევრობა. მაგალითად,
თუ გადავწყვეტთ, რომ ჯერ დავხატოთ ფანჯრები და შემდეგ კედლები, რომელსაც გავაფერადებთ, ამ შემთხვევაში უნდა 
გავითვალისწინოთ, რომ კედლები გადაფარავს ფანჯრებს და ვერ დავინახავთ. ამ პრობლემის გამოსასწორებლად 2 გზა არსებობს:
* შევცვალოთ ფუნქციების შესრულების მიმდევრობა: ჯერ კედლები დავხატოთ, შემდეგ ფანჯრები
* გამოვიყენოთ sendToFront() ან sendForward()  ფუნქციები. პირველი დახმარებით ობიექტი პირველ დონეზე გადავა, ხოლო
მეორეს დახმარებით კი ერთი დონით წინ გადავა.
