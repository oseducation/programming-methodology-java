$\text{\color{silver} პრობლემა:}$

დაწერეთ პროგრამა რომელიც იპოვის და დაბეჭდავს 1000000 მდე ყველა მერტივ რიცხვს


$\text{\color{silver} პრობლემის ამოხსნის გზები:}$

$\text{\color{#CD5C5C}  შენიშვნა}$: უმჯობესი იქნება თუ განვაზოგადებთ და ისეთ მეთოდს შევქმნით, რომელიც ბეჭდავს რიცხვებს 2-დან n-ის ჩათვლით მარტივ რიცხვებს.

1. შეგვიძლია დეკომპოზიციის საშუალებით მოცემული ამოცანა დავყოთ ორ ნაწილად. გადავუყვეთ $for$ ციკლით 2-დან 1000000-ის ჩათვლით რიცხვებს და თითოეულისთვის გავიგოთ, მოცემული რიცხვი მარტივია თუ არა. $for$ ციკლის დაწერის შემდეგ მთავარია თითოეული რიცხვისთვის მარტივობის დადგენა შევძლოთ. შევქმნათ მეთოდი $isPrime$, რომელსაც გადაეცემა რიცხვი და აბრუნებს იგი მარტივია თუ არა. ეს რომ დავწეროთ ამისთვის უნდა გავიხსენოთ თუ რას ნიშნავს მარტივი რიცხვი. <br>
მარტივია ყველა ის დადებითი რიცხვი, რომელსაც ორზე მეტი გამყოფი აქვს. ნებისმიერი დადებითი რიცხვი იყოფა ერთზე და თავის თავზე უნაშთოდ. შესაბამისად თუ მოცემულ რიცხვს სხვა გამყოფი არ აქვს ამ ორის გარდა, იგი მარტივია. <br> 
თუ რიცხვი 2-ზე ნაკლებია (ციფრი 1 მარტივი არაა) შეგვიძლია პასუხი $false$ დავაბრუნოთ ეგრევე. თუ რიცხვს არ აქვს გამყოფი მის ფესვამდე, არც ამ რიცხვის ფესვის შემდგომ ექნება გამყოფი.<br>
დამტკიცება:
$\forall \ n \ |\ n > 1\ \land \ n \in N \ \implies n = a * b$
$sqrt(n) = m \implies m * m = a * b$<br>
აქ გვაქვს სამი შემთხვევა:
ა) $a > m \implies b < m$
ბ) $a = m \implies b = m$
გ) $a < m \implies b > m$ <br>
აქედან გამომდინარე $min(a, b) \le m$,  შესაბამისად ერთი გამყოფი ფესვზე ყოველთვის ნაკლები ან ტოლია, ხოლო მეორე მეტი ან ტოლი. აქედან გამომდინარე, თუ რიცხვის გამყოფს მოვძებნით ფესვის ჩათვლით და ვერ ვიპოვით, ეს რიცხვი მარტივი იქნება (ვერ მოიძებნება სხვა a და b, 1-სა და n-ის გარდა) <br>
<li>
$\text{\color{#CD5C5C}  შენიშვნა}$: ასევე ყურადღებით უნდა ვიყოთ, რომ არ გამოგვრჩეს რაიმე ქეისი, მაგალითად ის, რომ მარტივი რიცხვები დადებითი რიცხვებია მარტო, 2დან მოყოლებული.
</li> <br>
$\scriptsize \it იხ. \ კოდი \ AllPrimes.java \ ფაილში.$ 
<br>
<br>

2. მეორე ვარიანტია მარტივობის დასადგენად პირდაპირ ბოლომდე გადავყოლიყავით რიცხვს და არა მის ფესვამდე. ეს ამოხსნა შედარებით ნელია, რადგან უფრო მეტ ოპერაციას ასრულებს.

```Java
private boolean isPrime(int n) {
  for(int i = 2; i <= n; i++){
    if(n % i == 0) return false; 
  }
  return true;
}
```

3. $\text{\color{#CD5C5C}  გაეცანით მხოლოდ იმ შემთხვევაში, თუ იცით რა არის მასივი! }$ეს ზედა ორთან შედარებით ბევრად ჩქარია. ამ ალგორითმს ერასტოთენეს საცერს ეძახიან, რომელიც მდგომარეობს შემდეგში. ვქმნით ბულიანების მასივს sieve-ს n+1 ზომისას (ამ შემთხვევაში n = 1000000), რომელიც აკმაყოფილებს შემდეგ პირობას: <br>
$\forall \  i \ \ | \ \ i > 1 \ \land \ i \in N \ \land \ i < n+1 \ \implies \ (isPrime(i)\ =\ !sieve[i])$ <br>
ალგორითმი მუშაობს შემდეგნაირად: 
ჩვენი მისიაა მოვნიშნოთ ყველა შედგენილი რიცხვი. რომ ჩამოვწეროთ რიცხვები 2-დან n-ის ჩათვლით: $2\ 3\ 4\ 5\ 6\ \dots \ n$. აქედან ავიღოთ პირველი რიცხვი, რომელიც მარტივი იქნება. მოვნიშნოთ ყველა რიცხვი, რომელიც იყოფა მასზე (ამ შემთხვევაში 2-ზე). აქედან გადავიდეთ შემდეგ მოუნიშნავ რიცხვზე (ამ შემთხვევაში 3-ზე). გავიმეოროთ იგივე პროცესი. მერე გადავალთ 5-ზე და ასე შემდეგ. როცა მოვრჩებით ამათ მონიშვნას, გადავუყვეთ მასივს 2-დან n-მდე და დავბეჭდოთ ინდექსი იმ შემთხვევაში, თუ მასივში ამ ინდექსზე მისი მნიშნველობა $false$-ია.

```Java
private void printPrimeNumbers(int n){
  boolean[] sieve = new boolean[n+1];
  for(long i = 2; i*i<=n; i++){
    if(sieve[(int) i] == true) continue;
    
    for(long j = i*i; j<=n; j+=i){
      sieve[(int) j] = true;
    }
  }
  for(int i = 2; i<=n; i++) {
    if(sieve[i] == false) println(i);
  }
}
```
<li> 
თუ კოდს დააკვირდებით, ნახავთ რომ გვჭირდება ორი ციკლი. გარე ციკლს გადავუყვებით n-ის ფესვის ჩათვლით (ზემოთ აღნიშნული მიზეზის გამო მაგაზე დიდი მარტივი გამყოფი n-ზე ნაკლები ან ტოლი სიდიდის რიცხვს ვერ ექნება). შიდა ციკლში კი ვიწყებთ $j = i * i$-დან, რადგან აქამდე სხვა მარტივი რიცხვებით შედგენილი რიცხვები მონიშნული იქნებოდა. გადავუყვებით n-ის ჩათვლით და ყოველ ბიჯზე j იზრდება i-ს ტოლი სიდიდით.
</li>
<br>
<li> 
$\text{\color{#CD5C5C}  შენიშვნა}$: შეიძლება იფიქროთ, რომ მეორეჯერ 2-დან n-ის ჩათვლით გადაყოლის ნაცვლად პირდაპირ დაპრინტოს პირველივე გარე ციკლში მარტივი რივხვები:
</li> 

```Java
for(long i = 2; i * i<=n; i++){
  if(sieve[(int) i] == true) continue;
  println(i); // ასეთნაირად
  for(long j = i * i; j<=n; j+=i){
    sieve[(int) j] = true;
  }
}
```

ეს სამწუხაროდ არ იმუშავებს, რადგან გარე ციკლი n-ის ფესვამდე მუშაობს. ამიტომაც $sqrt(n)$-ზე დიდი მარტივი რიცხვების დაბეჭვდა დაგვავიწყდება. <br>
<li>
$\text{\color{#CD5C5C}  შენიშვნა}$: ასევე <strong>უცილებელია</strong> $long$ ტიპის გამოყენება $int$-ის ნაცვლად $for$ ციკლში, რადგან $i * i$ შესაძლოა გაცდეს $int$-ის საზღვარს $2^{32}-1$
</li> 