# FillFirstRow

ამოცანა:
```
კარელი დგას 1x1 უჯრაზე, შეავსებინეთ მას პირველი ქუჩა ბრილიანტებით. ანუ პირველი ქუჩის ყველა უჯრაზე უნდა იდოს ზუსტად ერთი ბრილიანტი. ჩათვალეთ რომ საწყისი სამყარო ცარიელი არ არის და გარკვეულ(ჩვენთვის უცნობ) უჯრებში თითო(მხოლოდ ერთი) ბრილიანტი დევს.
```

## ამოცანის ამოხსნა
რადგანაც კარელი თავიდანვე 1x1 უჯრაზე იმყოფება, ქუჩის შეცვლა არ დაგვჭირდება. იმისთვის რომ ქუჩა ბოლომდე გავიაროთ, გამოვიწყენოთ `while` ციკლი, მანამ სანამ კარელი არ აღმოჩნდება ქუჩის ბოლოში, ანუ კედელთან. ამისთვის გამოვიყენოთ `frontIsClear` ბრძანება და `move` ბრძანებით თითო უჯრით გადავინაცვლოთ. მაშინ, როცა კარელი ქუჩის ბოლოში აღმოჩნდება `frontIsClear` შემოწმება დაგვიბრუნებს `false`-ს, რაც გამოიწვევს ციკლის გაჩერებას და კარელი უკვე ქუჩის ბოლოშია. ამოცანის მეორე ნაწილი ბრილიანტების ჩალაგებაა, ამისთვის მოძრაობის პარალელურად ყოველ უჯრაზე შევამოწმოთ ბრილიანტების მდგომარეობა `checkBeeper` მეთოდით, რომელიც ამოწმებს უჯრას, სადაც კარელი იმყოფება ბრძანებით `noBeepersPresent` და როდესაც უჯრაში ბრილიანტი არ დევს, ეს ბრძანება დაგვიბრუნებს `true`-ს და მხოლოდ ამ შემთხვევაში დაამატებს კარელი უჯრაზე ბრილიანტს, მაშინ როცა დაგვიბრუნდება `false`, ნიშნავს რომ უჯრაში უკვე ბრილიანტია და დამატების საჭიროება არ არის. გასათვალისწინებელია, ის რომ ციკლით ჩვენ ვამოწმებთ ჯერ უჯრის მდგომარეობას და შემდეგ ვაკეთებთ ბიჯს 1 უჯრით, ამიტომ მაშინ როდესაც ციკლი მორჩება და კარელი ქუჩის ბოლოს იქნება, აღმოჩნდება, რომ ბოლო უჯრა შეუმოწმებელია. ამიტომაც კიდევ ერთხელ გამოვიძახებთ `checkBeeper` მეთოდს. ამის შემდეგ პირველი ქუჩა სრულად არის შევსებული ბრილიანტებით.

## რატომ იმუშავებს ეს ამოხსნა ყველა სამყაროსთვის?
ჩვენი ამოხსნა დამყარებულია `while` ციკლზე და არა სამყაროს ზომებზე. ნებისმიერი ზომისთვის "შემოწმება-ბიჯის" იტერირება და ბოლო ბრილიანტის შემოწმება სწორად შეასრულებს ამოცანას. განვიხილოთ სამყაროს ზომები ზოგადად:
* nxm
ნებისმიერი nxm სამყარო, თავისთავად დაიყვანება nx1-ზე, რადგანაც პირველ ქუჩას არ ვტოვებთ, ამიტომ მხოლოდ ამ ქუჩაზე დაკვირვება საკმარისი იქნება.
* nx1
`while` ციკლი უზრუნველყოფს იმას, რომ კარელმა ქუჩა მთლიანად გაიაროს და ყოველი ბიჯის წინ შეამოწმოს ბრილიანტი. n-ცალ უჯრაში n-1 ნაბიჯის გაკეთებაა შესაძლებელი, ესე იგი ციკლის ბოლოს თამამად შეგვიძლია ვთქვათ, რომ ბიჯის რაოდენობის ტოლი, ანუ n-1 ცალი ბრილიანტი დევს პირველ ქუჩაზე, პირველ n-1 უჯრაში. მის n-მდე შესავსებად, 1 ცალი ბრილიანტის არსებობაა საჭირო მე-n უჯრაზე, რომელიც ციკლის დასრულების შემდეგ უნდა შევამოწმოთ, რადგან ციკლის ბოლოს კარელი ზუსტად ამ უჯრაზე, კედელთან იმყოფება. შესაბამისად ამ შემოწმების შემდეგ აღმოჩნდება, რომ პირველ ქუჩაზე n უჯრაში, n ცალი ბრილიანტი დევს, თითოში-თითო, რაც ნიშნავს რომ ამოცანა გადაჭრილია.
* 1x1
`while` ციკლი თავიდანვე არ ამუშავდება, რადგან `frontIsClear` ბრძანება დაგვიბრუნებს `false`-ს, რის გამოც, მოხდება მხოლოდ `checkBeeper` მეთოდის გამოძახება, რაც შეამოწმებს 1x1 უჯრას და უზრუნველყოფს, რომ მასზე 1 ბრილიანტი იდოს. საბოლოოდ პირველი ქუჩა ბრილიანტებით მაინც შეივსო და ამოხსნა სწორია.

## რა საჭიროა `while`-ის შემდეგ `checkBeeper` მეთოდის გამოძახება?
დავუშვათ `checkBeeper` მეთოდი არ გამოვიძახეთ ციკლის შემდეგ, ანუ ჩვენი კოდი გამოიყურება ასე:
```java
while(frontIsClear()) {
	checkBeeper();
	move();
}
```
განვიხილოთ თუნდაც 2x1 ზომის სამყარო. მაშინ როცა კარელი იმყოფება 1x1 უჯრაში `frontIsClear` შემოწმება გვიბრუნებს `true`-ს, ამიტომ კარელი ამოწმებს 1x1 უჯრას, და გადადის 2x1-ზე. ახლა კარელი იმყოფება 2x1 უჯრაში `frontIsClear` შემოწმება გვიბრუნებს `false`-ს, ამიტომ ციკლი წყდება და ჩვენი კოდიც სრულდება. სამყარო გამოიყურება შემდეგნაირად:
[Image Of Karel Standing on 2nd Box](/problem-set/images/5.Off-By-One-Error.png)
ყურადღება მივაქციოთ, რომ არსად არ შემოწმებულა ეს 2x1 უჯრა, შესაბამისად ჩვენ არ გვაქვს ინფორმაცია უჯრაზე. სადაც კარელი იმყოფება ციკლის ბოლოს. ამიტომ ციკლის გარეთ `checkBeeper` მეთოდის გამოძახება გადაგვიჭრის ამ პრობლემას. ახლა უკვე, როცა ციკლი შეწყდა და კარელი 2x1 უჯრაზე იმყოფება, ციკლის გარეთ მას უწევს `checkBeeper` მეთოდის გამოძახება და 2x1 უჯრაც შემოწმებულია.
* ამ შეცდომას პროგრამირებაში [Off-By-One Error](https://stackoverflow.com/questions/2939869/what-is-an-off-by-one-error-and-how-do-i-fix-it)-ს უწოდებენ.
