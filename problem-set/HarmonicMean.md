# HarmonicMean 

პრობლემა: 
```
კონსოლიდან წაიკითხეთ სამი მთელი რიცხვი და დაბეჭდეთ მათი საშუალო ჰარმონიული.
```


## პრობლემისს გადაჭრის გზა

* წავიკითხოთ მოხმარებლის მიერ შემოტანილი ინფორმაცია (int-ები).
* დავითვალოთ ამ შემოტანილი ინფორმაციის ჯამი (ამაზე დეტალურად ვისაუბრებთ ქვემოთ).
* დავითვალოთ გაერთიანებით მიღებული ინფორმაცია (ამაზე დეტალურად ვისაუბრებთ ქვემოთ).
* დავაბრუნოთ ამ ორი რიცხვის შეფარდება.


---

### ინფორმაციის წაკითხვა 

შევქმნათ სამი int ცვლადის ტიპი და შევინახოთ შემომავალი ინფორმაცია მათში:

```java 
int x = readInt("Enter a number: ");
int y = readInt("Enter a number: ");
int z = readInt("Enter a number: ");
```
---

### ამოხსნა:

საშუალო ჰარმონიულის ფორმულა სამი რიცხვისათვის: 1/(1/a + 1/b + 1/c) = abc/bc + ac + ab

*შევქმნათ `double HarMean` მეთოდის რომელსაც გადავცემთ შემოსულ ინფორმაციას ანუს სამ რიცხვს.
`double` ტიპი გვინდა, იმიტომ რომ წილადი შეიძლება მთელი რიცხვი არ იყოს.
*შევქმნათ `double numerator`, რომელიც იქნება a*b*c-ს ნამრავლი და რომელიც იქნება დასაბრუნებელი შედეგის მრიცხველი.
*შევქმნათ  	`double denominator`, რომელიც იქნება bc + ac + ab-ს ჯამი (გაერთიანებული წიდალის მრიცხველი: 1/a + 1/b + 1/c) და 
რომელიც არის და დასაბრუნებელი შედეგის მნიშვნელი.
* `double` ტიპი გამოვიყენეთ იმიტომ, რომ დაბრუნების მომენტში დაკასტვა აღარ დაგვჭირვებოდა,  თუმცა შეგვეძლო int ტიპის ცვლადები 
გამოგვეყენებინა და მერე დაბრუნების მომენტში დაგვეკასტა `double`.
*დავაბრუნოთ numerator/denominator-ზე.

```java
      double numerator = x * y * z;
      double denominator = y * z + x * z + x * y;
      return numerator/denominator;    
```
---


### შესაძლო ხარვეზები:
*თუ a,b და c საკმაოდ დიდი რიცხვები აღმოჩდნენ, შესაძლოა ისინი ვერ ჩაეტივნონ `double`-ში. ამ პრობლემის მოგვარება გარკვეულ დონეზე
შეგვიძლია უ.ს.ჯ-ს დახმარებით. a * b * c -ს მაგივრად გვექნებოდა უ.ს.ჯ (a,b,c) და მნიშვნელიც უფრო პატარა რიცხვი იქნებოდა.

---

### შესაძლო ამოხსნები:

*განვიხილოთ ერთი პრობლემის გადაჭრის გზა, რომელსაც საკმაოდ ხშირად იყენებენ ამ ამოცანის ამოხსნისას.
```java
    double a = (double)1/x;
    double b = (double)1/y;
    double c = (double)1/z;
    double denominator = a + b + c;
    double result = 1/denominator;
    return result;   
```
თითქოს არაფერი, იგივე ფორმულაა გამოყენებული, თუმცა არ უნდა დაგვავიწყდეს პერიოდული რიცხვები რომელსაც პროგრამა ვერ გამოითვლის ბოლომდე.
დავუშვათ მოხმარებელმა შეიყვანა მონაცემები 2, 3 და 6. ზემოთ მოცემული ამოხსნა დააბრუნებდა 1.0000000000000002-ს, როდესაც უნდა დაერბუნებინა 1.

