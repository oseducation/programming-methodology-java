# loseEverything

## პრობლემა:
მოხმარებელს აქვს საწყისი თანხა 1000, თამაშობს მანამ სანამ არ წააგებს ყველაფერს. ყოველ
ჯერზე შეყავს ფსონის თანხა და რიცხვი რომელზეც დებს. ხდება რულეტკის დატრიალების
სიმულაცია(0-დან 36-მდე შემთხვევითი რიცხვი), მოგების შემთხვევაში მოთამაშეს
უორმაგედბა დადებული თანხა წაგების შემთხვევაში კი მოთამაშე კარგავს დადებულ თანხას.
მოთამაშე მოგებულია მაშინ თუ რულეტკაზე ამოსული რიცხვი ემთხვევა მის მიერ დადებულ
რიცხვს. პროგრამა ყოველ მოქმედებაზე უნდა ბეჭდავდეს შესაბამის შეტყობინებას, ადვილად
რომ გაერკვეს მოთამაშე, რა რიცხვი ამოვიდა, რამდენი წააგო, რამდენი მოიგო, რამდენი აქვს
ბალანსი.

## ამოხსნა:
პირველ რიგში ჩვენი პრობლემა დავყოთ რამდენიმე ნაწილად:
* საწყისი ბალანსის ინიციალიზაცია
* თამაშის სიმულაცია (0 დან 36-დე რიცხვის არჩევა)
* მომხმარებლისთვის შეტყობინების გამოტანა

---

### მომზადება პრობლემის გადასაჭრელად
კარგი იქნება, თუ საწყის თანხას მუდმივად(private static final int) გავიტანთ, რათა სურვილის შემთხვევაში მარტივად შევძლოთ შეცვლა. მოვიფიქროთ, თუ როგორ მოვახდენთ რულეტკის სიმულაციას. ამოხსნის გზის მოფიქრების შემდეგ ავაგოთ შესაბამისი დეკომპოზიციური სურათი. 

---

### ამოხსნა

* ჯერ ვიფიქროთ რულეტკის დატრიალების სიმულაციაზე.
 ვთვლით, რომ რულეტკა 0-დან 36-მდე თითოეულ რიცხვზე თანაბარი ალბათობით მოხვდება. პროგრამაში ეს შეგვიძლია randomGenerator-ის დახმარებით გავაკეთოთ. მის `readInt()` ფუნქციას თუ გადავცემთ 2 არგუმენტს, 0-სა და 36-ს, თანაბარი ალბათობით დაგვიბრუნებს ამ ინტერვალში რომელიმე რიცხვს. ერთი დატრიალების ფსევდო კოდი ასე გამოიყურება:

---
    დავაგენერიროთ რიცხვი `num` 0-დან 36მდე;
    თუ მომხმარებლის შემოყვანილი რიცხვი დაემთხვა `num`-ს
        გავზარდოთ მომხმარებლის ბალანსი
    წინააღმდეგ შემთხვევაში 
        შევამციროთ მის მიერ დადებული თანხის მიხედვით.
---

* მომხმარებლის მიერ ფსონი დადება
პირველ რიგში, მომხმარებელი დებს თანხას, შემდეგ კი ცდილობს გამოიცნოს რულეტკაზე რა რიცხვი მოვა. ორივეს იმპლემენტაცია შესაძლებელია `readInt()` ფუნქციით. უნდა გავითვალისწინოთ, რომ მომხმარებელი არასწორი რიცხვი არ შემოიყვანოს. მაგალითად, დარჩენილ ბალანსზე მეტი თანხა არ დადოს, ან არასწორი რიცხვის გამოცნობა არ სცადოს. ანუ, უნდა შევამოწმოთ მომხმარებლის მიერ შემოყვანილი რიცხვი, თუ რაიმე საზღვრებს არ სცდება. შესაბამისად, კარგი იქნება, თუ დავწერთ მეთოდს, რომელიც შემოაყვანინებს მომხმარებელს რიცხვს, გამოიტანს შესაბამის მესიჯს და შეამოწმებს ამ რიცხვს საზღვრებზე. მომხმარებელს იქამდე უნდა ვთხოვოთ რიცხვის შემოყვანა, სანამ სწორად არ მოახერხებს ამას. ამისთვის `while` ციკლი გამოგვადგება. მივიღებთ კოდს:

```java
	int askUser(String message, int lowerBound, int upperBound) {
		int num = readInt(message);
		while (num < lowerBound || num > upperBound) {
			num = readInt("Wrong input, try again: ");
		}
		return num;
	}
```

არ დაგვავიწყდეს, რომ მომხმარებელი მარტივად უნდა გაერკვეს რამდენი თანხა დარჩა, რამდენი წააგო და ა.შ. შესაბამისად, ყოველი მოგებული ან წაგებული თამაშის შემდეგ უნდა გამოვიტანოთ მისი ბალანსი. ეს ყველაფერი იქამდე უნდა გავაგრძელოთ, სანამ თანხა 0-ს არ გაუტოლდება. მივიღებთ კოდს:

```java
		while (deposit > 0) {
			int bet = askUser("Place your bet: ", 0, deposit);
			int guess = askUser("Choose number between 0 and 36: ", 0, 36);
			int num = rgen.nextInt(0, 36);
			if (guess == num) {
				deposit *= 2;
				println("You Win! current balance: " + deposit);
			} else {
				deposit -= bet;
				println("You lose. current balance: " + deposit);
			}
		}

		println("Game Over, Good Game");
```

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
მთავარი შეცდომა, რაც შეიძლება დავუშვათ, არის მომხმარებლის "ნდობა" და მისი შემოყვანილი რიცხვის არ-შემოწმება. არასწორმა რიცხვმა შეიძლება სრულიად არიოს პროგრამა. ამიტომ არის გამოსადეგი `askUser` მეთოდი.

## ამოხსნის ალტერნატიული გზა
შეგვეძლო 1 მთლიანი დატრიალების სიმულაციის ნაცვლად შეგვექმნა მეთოდი, რომელიც მთელ რიცხვს დააბრუნებდა მოთამაშის არჩეული რიცხვის მიხედვით. მაგალითად, თუ მოიგებდა დავაბრუნებდით რა თანხა მოიგო, თუ წააგებდა - რა წააგო. სანამ ბალანსი 0-ზე მეტი იქნებოდა, გამოვაკლებდით ამ ფუნქციის მიერ დაბრუნებულ რიცხვს.
