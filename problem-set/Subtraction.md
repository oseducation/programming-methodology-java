# Subtraction

ამოცანა:
```
კარელმა უნდა გამოაკლოს ორი რიცხვი, 2x1 უჯრაზე დევს n ცალი ბრილიანტი, 3x1 უჯრაზე m ცალი ბრილიანტი, კარელმა 4x1 უჯრაზე უნდა დადოს n-m ბრილიანტი. ჩათვალეთ, რომ კარელს ჩანთაში უსასრულო რაოდენობის ბრილიანტი აქვს და ჩათვალეთ, რომ n>=m.
```
## ამოცანის ამოხსნა
ამოცანა დავყოთ ორ კომპონენტად:
* გავიგოთ სხვაობა მეორე და მესამე უჯრაზე განთავსებული ბიპერების რაოდენობებს შორის.
* მიღებული სხვაობა გადავიტანოთ მეოთხე უჯრაზე.
ორივე კომპონენტისთვის ცალკე მეთოდი დავწეროთ.

## დამხმარე მეთოდი `moveBackwards()`
ამოცანის ამოხსნაში ხშირად დაგვჭირდება კარელის ერთი უჯრით უკან წაყვანა.
ამის გასაკეთებლად შემდეგი კოდი გვჭირდება:
```java
turnAround();
move();
turnAround();
```
ყოველ ჯერზე ამ სამი ბრძანების თავიდან წერა რომ არ მოგვიწიოს, შეგვიძლია ეს კოდი ცალკე მეთოდად გავიტანოთ და პირდაპირ ეს მეთოდი გამოვიძახოთ:
```java
private void moveBackwards() {
    turnAround();
    move();
    turnAround();
}
```
შინაარსიდან გამომდინარე მას `moveBackwards()` ვუწოდოთ. ამოხსნაში იგი არაერთხელ დაგვჭირდება.
### მეორე და მესამე უჯრების სხვაობის გაგება
დავდგეთ მესამე უჯრაზე და მასზე განთავსებული ყოველი ბიპერისთვის ერთი ბიპერი მოვაკლოთ ამ უჯრასაც და მის წინა, ანუ მეორე უჯრასაც. ამის გასაკეთებლად გამოვიყენოთ `while` ციკლი. ციკლის ყოველი ბიჯის ბოლოს კარელი საწყის პოზიციაზე, ანუ მესამე უჯრაზე უნდა დავაბრუნოთ.
ამოხსნის ეს ნაწილი კოდში ასე აისახება:
```java
while(beepersPresent()) {
    pickBeeper();
    moveBackwards();
    pickBeeper();
    move();
}
```
ეს კოდი შეგვიძლია ცალკე მეთოდად წარმოვადგინოთ. კითხვადობისთვის მას `subtractFromThree()` დავარქვათ. მეთოდის დასრულების შემდგომ მეორე უჯრაზე დაგვრჩება n-m ბიპერი, კარელი კი მესამე უჯრაზე იქნება. `moveBackwards()` მეთოდით კარელს გადავიყვანთ მეორე უჯრაზე.

### სხვაობის გადატანა მეორე უჯრიდან მეოთხე უჯრაზე
ახლა მეორე უჯრაზე ვიმყოფებით და გვინდა, რომ აქ განთავსებული ყოველი ბიპერი გადავიტანოთ მეოთხე უჯრაზე. ამ შემთხვევაშიც `while` ციკლი დაგვჭირდება. არ უნდა დაგვავიწყდეს, რომ ბიპერის გადატანის შემდგომ, კარელი საწყის პოზიციაზე, ანუ მეორე უჯრაზე დავაბრუნოთ. წინააღმდეგ შემთხვევაში ციკლის არ იმუშავებს სწორად.
```java
while(beepersPresent()) {
    pickBeeper();
    move();
    move();
    putBeeper();
    moveBackwards();
    moveBackwards();
}
```
წინა შემთხვევის მსგავსად, კარგი იქნება ამ კოდსაც თუ ცალკე მეთოდად წარმოვადგენთ. შინაარსიდან გამომდინარე მას `transferLeftovers()` ვუწოდოთ. მეთოდის დასრულების შემდგომ მეოთხე უჯრაზე n-m ბიპერი იქნება მოთავსებული.

## რატომ იმუშავებს ეს ამოხსნა ყველა სამყაროსთვის?
დააკვირდით იმ ფაქტს, რომ ჩვენი ამოხსნა არ იყენებს არც სამყაროს ზომებს და არც n-ისა და m-ის მნიშვნელობას. იგი `while` ციკლზე არის დაფუძნებული და ყოველ ნაბიჯზე თითო-თოთო ბიპერის აღებით/გადადებით ითვლის შედეგს. `subtractFromThree()` მეთოდი მეორე და მესამე უჯრებიდან ჯერ 1, მერე 2 და ა.შ ბიპერს აიღებს. ანალოგიურად, `transferLeftovers()` მეთოდიც ჯერ 1, მერე 2 და ა.შ ბიპერს გადაიტანს მეოთხე უჯრაზე. ორივე მეთოდში დაწერილი ციკლის თითოეული იტერაცია ერთი ნაბიჯით გვაახლოვებს შედეგთან, ე.ი. n-ისა და m-ის ნებისმიერი სასრული მნიშვნელობისათვის ჩვენი ამოხსნა სწორად იმუშავებს.

## რატომ ვიყენებთ `while` ციკლს `for` ციკლის ნაცვლად? ან საერთოდ რა საჭიროა ციკლი?
* `while` ციკლის უპირატესობა `for`-თან შედარებით არის ის, რომ არ არის აუცილებელი წინასწარ ვიცოდეთ ციკლის ნაბიჯების რაოდენობა. უბრალოდ გვაქვს პირობა `beepersPresent()`, რომელიც შეიძლება 5 ნაბიჯის შემდგომ, ან კიდევ 100 ნაბიჯის შემდგომ დაირღვეს. `while` ციკლი ყველა ასეთ შემთხვევაში იმუშავებს.
* ციკლი კი იმიტომ არის საჭირო, რომ ჩვენმა ამოხსნამ ნებისმიერი სამყაროსთვის იმუშავოს. შეიძლება კონკრეტული n-ისა და m-ისთვის პირდაპირ გამოგვეთვალა სხვაობა და ამდენივე ბიპერი დაგვედო მეოთხე უჯრაზე, მაგრამ ეს კოდი ყველა n-ისა და m-ის მნიშვნელობებისთვის არ იმუშავებდა.

## განსხვავებული მიდგომა `transferLeftovers()` მეთოდში
შეიძლება შეგემჩნიათ, რომ `transferLeftovers()` მეთოდში ორჯერ ვიძახებთ `moveBackwards()` მეთოდს, რაც ორჯერ აბრუნებს კარელს ერთი უჯრით. ამის მაგივრად, შეგვიძლია დავწეროთ მეთოდი, რომელსაც ერთხელ გამოვიძახებთ და მისი საშუალებით კარელს პირდაპირ ორი უჯრით უკან დავაბრუნებთ.
კოდი გამოიყურება ასე:
```java
private void moveBackwardsByTwo() {
    turnAround();
    move();
    move();
    turnAround();
}
```
ამ ცვლილების შედეგად  `transferLeftovers()` მეთოდში `moveBackwards()`-ის ორჯერ გამოძახების ნაცვლად შეგვიძლია `moveBackwardsByTwo()` -ს ერთხელ გამოძახება.
