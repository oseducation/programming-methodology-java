# Palindrome

პრობლემა:
```
დაწერეთ პრედიკატ მეთოდი რომელსაც გადაეცემა სტრინგი და რომელიც დაადგენს არის თუ
არა მოცემული ტექსტი პალინდრომი
```


## პრობლემის გადაჭრის გზა

პალინდრომი ეწოდება ისეთ ტექსტს, რომელიც წაღმა და უკუღმა ერთნაირად იკითხება.
ჩვენი ამოცანაა, დავწეროთ `private boolean isPalindrome(String s)` მეთოდის იმპლემენტაცია, რომელიც დააბრუნებს true-ს, თუ გადაცემული სტრინგი პალინდრომია.
იმისათვის, რომ გავარკვიოთ სტრინგი პალინდრომია თუ არა, გამოვიყენოთ შემდეგი ალგორითმი:
სტრინგი პალინდრომია, თუ მისი პირველი სიმბოლო ემთხვევა მის ბოლო სიმბოლოს, მეორე - ბოლოდან მეორეს, მესამე - ბოლოდან მესამეს და ა.შ თუ რომელიმე სიმბოლოსთვის ეს პირობა დაირღვა, ე.ი. ეს სტრინგი პალინდრომი არ ყოფილა.

---


## იმპლემენტაცია

ადვილად შესამჩნევია, რომ ამ ალგორითმის იმპლემენტაციისთვის გვჭირდება `for` ციკლი. ყოველ იტერაციაზე სტრინგის i-ური სიმბოლო უნდა შევადაროთ სტრინგის ბოლოდან მე-i სიმბოლოს. რადგან სტრინგის ბოლო სიმბოლოს ინდექსი არის `s.length() - 1`, სტრინგის ბოლოდან მე-i სიმბოლოს ინდექსი იქნება `s.length() - 1 - i`. თუ იტერაციაზე ეს სიმბოლოები არ არის ერთნაირი, შეგვიძლია შემოწმება შევწყვიტოთ და დავაბრუნოთ false; ხოლო თუ ციკლიდან გამოვედით, ე.ი. სტრინგი პალინდრომი ყოფილა და უნდა დავაბრონოთ true.
```java
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) != s.charAt(s.length() - 1 - i))
            return false;
    }
    return true;
```

შეიძლება შევამჩნიოთ, რომ პალინდრომობის დადგენისთვის შეგვიძლია ამ სტრინგის მხოლოდ პირველ ნახევარს გადავუყვეთ, მეორე ნახევარი კი ამ დროს ავოტომატურად შემოწმდება. ანუ, გვექნება:
```java
    for (int i = 0; i < s.length() / 2; i++) {
        if (s.charAt(i) != s.charAt(s.length() - 1 - i))
            return false;
    }
    return true;
```
---

## რატომ იმუშავებს კოდი ყველა შემთხვევისთვის?

განვიხილოთ ისეთი შემთხვევები, როდესაც სტრინგის ზომა არის 0 და 1.
როდესაც ცარიელი სტრინგი გადმოგვეცემა, პროგრამა ციკლში არ შევა, რადგან 0 < 0 (s.length() / 2 = 0) პირობა დასაწყისშივე მცდარი იქნება და დაბრუნდება true მნიშვნელობა.
როდესაც სტრინგი მხოლოდ ერთი სიმბოლოსგან შედგება, არც ამ შემთხვევაში შევა პროგრამა ციკლში, რადგან s.length() / 2 თავიდანვე 0-ის ტოლია და მეთოდი დააბრუნებს true-ს.

---

## ამოხსნის ალტერნატიული გზები

რა თქმა უნდა, შეგვიძლია ამოცანა სხვა ხერხებითაც ამოვხნათ. მაგალითად, რადგან პალინდრომი წაღმა და უკუღმა ერთნაირად იკითხება, შეგვიძლია სტრინგი შევაბრუნოთ და თუ თავდაპირველი და შებრუნებული სტრინგები ერთნაირია, დავაბრუნოთ true.
```java
	private boolean isPalindrome(String s) {
		String reversed = "";
		for (int i = 0; i < s.length(); i++) {
			reversed = s.charAt(i) + reversed;
		}
		return s.equals(reversed);
	}
```
ამის გარდა, სხვა უამრავი მეთოდი არსებობს, რომლებსაც შეგიძლიათ გაეცნოთ ბმულზე: https://www.geeksforgeeks.org/string-palindrome/