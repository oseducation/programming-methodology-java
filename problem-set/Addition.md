# Addition

## პრობლემა:
```
კარელმა უნდა შეკრიბოს ორი რიცხვი, 2x1 უჯრაზე დევს n ცალი ბრილიანტი, 3x1 უჯრაზე m
ცალი ბრილიანტი, კარელმა 4x1 უჯრაზე უნდა დადოს n+m ბრილიანტი. ჩათვალეთ, რომ
კარელს ჩანთაში უსასრულო რაოდენობის ბრილიანტი აქვს.
```



## პრობლემის გადაჭრის გზა

თუ კარელი 2x1 და 3x1 უჯრაზე არსებულ ბრილიანტებს როგორღაც გადაიტანს 4x1 უჯრაზე, 
4x1 უჯრაზე გვექნება იმდენი ბრილიანტი, რამდენიც იყო 2x1 და 3x1 უჯრებზე ერთად. ამით ჩვენი ამოცანა ამოიხსნება.

ეს ალგორითმი დავყოთ ორ ნაწილად:
1. 2x1 უჯრაზე მყოფი ბრილიანტები გადავიტანოთ 4x1 უჯრაზე
2. 3x1 უჯრაზე მყოფი ბრილიანტები გადავიტანოთ 4x1 უჯრაზე

როგორც ვხედავთ, ეს ორი ნაბიჯი ძალიან ჰგავს ერთმანეთს. 
თუ ერთ-ერთის იმპლემენტაციას გავაკეთებთ, მცირე ცვლილებებით მივიღებთ მეორეს.

ვთქვათ ვართ 2x1 ან 3x1 უჯრაზე, ახლა გვაქვს შემდეგი ამოცანა: როგორ გადავიტანოთ ბრილიანტები ერთი უჯრიდან მეორეზე?

ამ პრობლემის გადაჭრისას შეიძლება წავიდეთ შემდეგი გზით: 
1. ერთდროულად ავიღოთ ყველა ბრილიანტი
2. მივიდეთ 4x1 უჯრაზე
3. დავდოთ აღებული ბრილიანტები

თუმცა ამ ალგორითმს აქვს ხარვეზი და ვერ იმუშავებს სწორად. 
უნდა გავითვალისწინოთ ის ფაქტი, რომ კარელს თავიდან ჩანთაში აქვს უსასრულო რაოდენობის ბრილიანტი, 
შესაბამისად, როდესაც უჯრიდან ავიღეთ ყველა ბრილიანტი და გადავედით 4x1 უჯრაზე, ჩანთაში ისევ უსასრულო რაოდენობის ბრილიანტი გვაქვს -
ანუ დავკარგეთ ინფორმაცია 2x1 უჯრაზე არსებული ბრილიანტების რაოდენობაზე.

განვიხილოთ იმავე პრობლემის გადაჭრის სხვა გზა: ბრილიანტები სათითაოდ გადავიტანოთ ერთი უჯრიდან მეორეზე.
ამ შემთხვევაში რამდენ ბრილიანტსაც ავიღებთ ერთი უჯრიდან, იმდენ ბრილიანტს დავდებთ მეორე უჯრაზე - არ ვკარგავთ ინფორმაციას ბრილიანტების რაოდენობაზე, ალგორითმი სწორად იმუშავებს.


## ალგორითმი

ახლა ჩამოვაყალიბოთ ალგორითმი თავიდან ბოლომდე:

1. გადავიდეთ 2x1 უჯრაზე
2. ბრილიანტები სათითაოდ გადავიტანოთ 2x1 უჯრიდან 4x1 უჯრაზე
3. გადავიდეთ 3x1 უჯრაზე
4. ბრილიანტები სათითაოდ გადავიტანოთ 3x1 უჯრიდან 4x1 უჯრაზე


## იმპლემენტაცია

დავიწყოთ იმპლემენტაცია:

1. გადავიდეთ 2x1 უჯრაზე
რადგან დასაწყისში კარელი დგას 1x1 უჯრაზე, 2x1 უჯრაზე გადასასვლელად გვჭირდება მხოლოდ `move()` ბრძანება

2. ბრილიანტები სათითაოდ გადავიტანოთ 2x1 უჯრიდან 4x1 უჯრაზე
ამისათვის საჭიროა:
   * გადავიტანოთ ერთი ბრილიანტი 2x1 უჯრიდან 4x1 უჯრაზე
   * ეს მოქმედება გავიმეოროთ მანამ, სანამ 2x1 უჯრაზე იქნება ბრილიანტები

ანუ, სანამ 2x1 უჯრაზე იქნება ბრილიანტები კარელმა:
   - უნდა აიღოს ბრილიანტი
```java	
		pickBeeper();
```
   - გადავიდეს 4x1 უჯრაზე	
```java	
		move();			
		move(); 
```
   - დადოს ბრილიანტი		
```java
		putBeeper();
```
   - დაბრუნდეს უკან 2x1 უჯრაზე
	ამისთვის საჭიროა, შემობრუნდეს და გადავიდეს 2x1 უჯრაზე
```java
		turnAround();
		move();
		move();
```

ახლა საჭიროა მიღებული ბრძანებები ჩავწეროთ ციკლში:
```java
while (beepersPresent()) {
	pickBeeper();
	move(); 
	move(); 
	putBeeper();
	turnAround(); 
	move(); 
	move(); 
}
```

თუმცა ამ მეთოდს ექნება ხარვეზი. ციკლის ბოლოს, 2x1 უჯრაზე დაბრუნების შემდეგ, კარელი იხედება დასავლეთით.
შესაბამისად, როცა ციკლში ახლიდან შევა და ბრილიანტს აიღებს, შეეცდება ორი `move()` ბრძანების გაკეთებას, რის შედეგადაც შეეჯახება კედელს.
ამ ხარვეზის გამოსასწორებლად, საჭიროა ციკლის ბოლოს კარელი შემოვატრიალოთ ისე, რომ აღმოსავლეთით იხედებოდეს.
	მივიღებთ საბოლოო და სწორ კოდს:
```java
	while (beepersPresent()) {
		pickBeeper();
		move();
		move();
		putBeeper();
		turnAround();
		move();
		move();
		turnAround();
	}
```

3. გადავიდეთ 3x1 უჯრაზე
რადგან წინა მეთოდის დასრულების შემდეგ კარელი დგას 1x1 უჯრაზე, 2x1 უჯრაზე გადასასვლელად გვჭირდება მხოლოდ `move()` ბრძანება

4. ბრილიანტები სათითაოდ გადავიტანოთ 3x1 უჯრიდან 4x1 უჯრაზე
ეს მეთოდი მეორე ნაბიჯში აღწერილი მეთდის მსგავსია. განსხვავება მხოლოდ ის იქნება, რომ ორი `move()` ბრძანების ნაცვლად დაგვჭირდება ერთი.
	შესამაბისად, გვექნება:
```java
    while (beepersPresent()) {
        pickBeeper();
        move();
        putBeeper();
        turnAround();
        move();
        turnAround();
    }
```


### როდესაც იმპლემენტაცია დავასრულეთ, დავფიქრდეთ, იმუშავებს თუ არა ჩვენი პროგრამა ყველა შემთხვევისთვის.

მაგალითად, მაშინ როდესაც 2x1 უჯრაზე არ გვაქვს ბრილიანტები.
ამ შემთხვევაში პროგრამა უბრალოდ არ შევა პირველ ციკლში (რომელსაც 2x1 უჯრიდან 4x1 უჯრაზე გადააქვს ბრილიანტები),
რადგან 2x1 უჯრაზე არ გვაქვს ბრილიანტები(`beepersPresent()` პირობა მცდარია) და პირდაპირ გადავა 3x1 უჯრაზე
იგივე ლოგიკა იმოქმედებს მაშინ, როდესაც 3x1 უჯრაზე არ გვაქვს ბრილიანტები - 3x1 უჯრაზე გადასვლის შემდეგ ციკლი აღარ შესრულდება და პროგრამა დასრულდება.
კოდი სწორად იმუშავებს იმ შემთხვევაშიც თუ არცერთ უჯრაზე არ გვაქვს ბრილიანტები:
ამ შემთხვევაში კარელი გადავა 2x1 უჯრაზე, პირველი ციკლი არ შესრულდება, კარელი გადავა 3x1 უჯრაზე, ბოლო ციკლი არ შესრულდება


## ამოხსნის ალტერნატიული გზები

რა თქმა უნდა, ეს არ არის ამ ამოცანის ამოხსნის ერთადერთი შესაძლო გზა. მაგალითად, შეგვიძლია წავიდეთ შემდეგი გზით:
დავწეროთ მეთოდი, რომელიც უჯრაზე არსებულ ბრილიანტებს ერთი უჯრით მარჯვნივ გადაიტანს და ეს მეთოდი გამოვიძახოთ ორჯერ - ამ შემთხვევაში ჯერ 2x1 უჯრაზე არსებულ ბრილიანტებს გადავიტანთ 3x1 უჯრაზე (ამ დროს 3x1 უჯრაზე უკვე გვექნება ბრილიანტების ჯამი), ხოლო შემდეგ ყველა ბრილიანს გადვიტანთ 4x1 უჯრაზე. ამ შემთხვევაში კოდს ექნება შემდგი სახე:
```java
	public void run() {
		move(); // (1, 1) -> (2, 1)
		transferBeepersBy1();
		move(); // (2, 1) -> (3, 1)
		transferBeepersBy1();
	}

	/*
	 * transfers beepers by one
	 *
	 * precondition: (x, 1) facing east
	 * postcondition: (x, 1) facing east
	 */
	private void transferBeepersBy1() {
		while (beepersPresent()) {
			pickBeeper();
			move(); // (x, 1) -> (x+1, 1);
			putBeeper();
			turnAround(); // facing west
			move(); // (x+1, 1) -> (x, 1)
			turnAround(); // facing east
		}
	}
```