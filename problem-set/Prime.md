# Prime

პრობლემა:
```
დაწერეთ პროგრამა რომელიც დაადგენს შეყვანილი რიცხვი მარტივია თუ არა.
```

## პრობლემის გადაჭრის გზა
პირველ რიგში გავიხსენოთ, თუ რა არის მარტივი რიცხვი. რიცხვს ეწოდება მარტივი, თუ მას მხოლოდ ორი განსხვავებული ნატურალური გამყოფი აქვს.
ნებისმიერი რიცხვი იყოფა 1-სა და საკუთარ თავზე, შესაბამისად რიცხვი რომ მარტივი იყოს, სხვა არც ერთ რიცხვზე არ უნდა იყოფოდეს.
კარგი დეკომპოზიციისთვის უკეთესი იქნება `run()` მეთოდის გარეთ აღვწეროთ boolean ტიპის `isPrime()` მეთოდი, რომელსაც გადავცემთ რიცხვს
და დაგვიბრუნებს რიცხვი არის თუ არა მარტივი.
`isPrime()` მეთოდში შევამოწმოთ მოცემულ რიცხვს აქვს თუ არა ერთისა და საკუთარი თავისაგან განსხვავებული ნატურალური გამყოფი.

---

## რიცხვების შემოწმება
'for' ციკლის მეშვეობით ჩვენ შეგვიძლია თითოეული რიცხვისთვის შევამოწმოთ არის თუ არა კონსოლიდან წაკითხული რიცხვის გამყოფი.
ერთი რიცხვი იყოფა მეორეზე, თუ მათი განაყოფის ნაშთი ნულის ტოლია. ნაშთის რიცხვობრივი მნიშვნელობის გაგება კი '%' სიმბოლოთი შეგვიძლია.

შესაბამისად, კოდი გამოიყურება შემდეგნაირად:
```java
    private boolean isPrime(int p){
        if(p < 2) return false;
        for(int i = 2; i < p; i++){
            if(p % i == 0){
                return false;
            }
        }
        return true;
    }
```

---

## რატომ იმუშავებს კოდი ყველა შემთხვევისთვის?

* განვიხილოთ ორი შემთხვევა, როდესაც რიცხვი 2-ზე მეტია ან ტოლია, ან ორზე ნაკლებია.
  თუ რიცხვი ორზე მეტია ან ტოლია, მაშინ ჩვენი კოდი ნებისმიერ შემთხვევაში სწორად იმუშავებს, რადგან მოცემულ რიცხვამდე
  ვამოწმებთ არის თუ არა რომელიმე რიცხვი მისი გამყოფი. კოდში არ ვიყენებთ ისეთ ოპერაციებს, რომლებმაც შესაძლოა რაიმე
  სახის ხარვეზი გამოიწვიოს.

* თუ რიცხვი 2-ზე ნაკლებია, ვიცით, რომ 2-ზე ნაკლები მარტივი რიცხვი არ არსებობს, შესაბამისად `isPrime()` მეთოდის დასაწყისში ვამოწმებთ
  არის თუ არა რიცხვი ნაკლები 2-ზე. ამ შემთხვევაში მეთოდი False-ს დაგვიბრუნებს, რის გამოც ჩვენი კოდი ყველა შემთხვევას გაითვალისწინებს.
---

## კოდის შესაძლო გაუმჯობესებები:

* იმისათვის, რომ შევამციროთ კოდის მუშაობის დრო ჩვენ შეგვიძლია რიცხვები არა p-მდე, არამედ p/2 მდე განვიხილოთ, რადგან ვიცით, რომ რიცხვს
  შეუძლებელია p/2-ზე უფრო დიდი ნატურალური გამყოფი ჰქონდეს.

```java

    Boolean isPrime(int p){
        if(p < 2) return false;
        for(int i = 2; i < p/2; i++){
            if(p % i == 0){
                return false;
            }
        }
        return true;
    }

```

* თუ კარგად დავაკვირდებით, შევამჩნევთ, რომ კოდის აჩქარება კიდევ არის შესაძლებელი, თუ რიცხვებს არა p/2-მდე, არამედ კვადრატული ფესვი
  p-ს ჩათვლით შევამოწმებთ, რადგან შეუძლებელია რიცხვს მასზე დიდი მარტივი გამყოფი ჰქონდეს. რიცხვის კვადრატული ფესვის მნიშვნელობის გაგება
  შეგვიძლია Math ბიბლიოთეკის sqrt მეთოდის საშუალებით.

```java
    
    Boolean isPrime(int p){
        if(p < 2) return false;
        for(int i = 2; i <= Math.sqrt(p); i++){
            if(p % i == 0){
                return false;
            }
        }
        return true;
    }
```

---

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
* კოდის იმპლემენტაციისას შესაძლოა გამოგვრჩეს ის შემთხვევა, როდესაც კონსოლში არადადებითი რიცხვი შემოგვდის. ამ შემთხვევაში
  ჩვენ მიერ დაწერილი კოდი არასწორ პასუხს დაგვიბრუნებს და ჩათვლის, რომ უარყოფითი რიცხვი მარტივია. ამიტომ აუცილებლად უნდა
  გავითვალისწინოთ ეს შემთხვევა შემდეგი შემოწმებით:
```java
    if(p < 2) return false;
```
