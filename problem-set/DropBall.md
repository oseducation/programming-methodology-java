${\text{\color{silver} პრობლემა: }}$

მაუსის კლიკზე იმავე ადგილზე ჩნდება ბურთი და იწყებს ვარდნას ძირს, თუ მაუსს სხვა
ადგილზე ვაკლიკებ ბურთი გადადის ახალ ადგილზე და იქედან იწყებს ვარდნას

${\text{\color{silver} პრობლემის გადაჭრის გზები: }}$

1. თავდაპირველად, ფიქრის ლოგიკური პროცესი შემდეგნაირია: პირველ დაკლიკებაზე უნდა შევქმნათ ბურთი, რომელიც სულ დაბლა ეცემა და ყოველ ახალ დაკლიკებაზე წინა ბურთი ახალ პოზიციაზე გადავიყვანოთ. ასეთ მიდგომას დასჭირდება რაიმე `boolean` ცვლადი, რომელიც გვეტყვის ბურთი შექმნილია თუ არა.
```java
private boolean isBallCreated = false;

public void mousePressed(MouseEvent event) {
    if(isBallCreated == false){
        add(ball, event.getX()-BALL_RADIUS, event.getY()-BALL_RADIUS);
        isBallCreated = true;
    }else{
        ball.setLocation(event.getX()-BALL_RADIUS, event.getY()-BALL_RADIUS);
    }
}
```
2. იდეაში შესაძლებელია ამ კოდის კიდევ უფრო შემცირება. როდესაც ობიექტი უკვე დამატებულია კანვასზე, მისი ახლიდან დამატების შემთხვევაში ობიექტი უბრალოდ პოზიციას იცვლის ახალ კოორდინატებზე (ანუ ზუსტად იმას აკეთებს რაც გვინდა). ეს განპირობებულია იმით, რომ გრაფიკს პროგრამამ უნდა აღრიცხოს ყველა ობიექტის, რომლებიც ჰიპში არიან შექმნილნი, ადგილმდებარეობა, რათა შემდგომ `getElementAt()`-ის გამოყენება შეგვეძლოს. რადგან ერთ ობიექტს ორი მისამართი ვერ ექნება (ალოგიკური იქნება) ამიტომაც არ იხატება ახლიდან კანვასზე ბურთი.

$\scriptsize \it იხ. \ კოდი \ DropBall.java \ ფაილში.$ 

${\text{\color{#e55555}{შენიშვნა}}}$

1. აუცილებელია `GOval`-ის გარეთ განსაზღვრა, რათა `mousePressed`-მა დააფიქსიროს.
2. უმჯობესია `mouseClicked`-ის ნაცვლად `mousePressed` გამოვიყენოთ, რადგან უფრო ეფექტურად აფიქსირებს კლიკებს.
3. `addMouseListeners` ბურთის ინიციალიზაციის მერე უნდა გვეწეროს, წინააღმდეგ შემთხვევაში შესაძლებელი იქნებოდა  `nullpointerexception` ამოეგდო.