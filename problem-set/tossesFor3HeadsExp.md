# tossesFor3heads

## პრობლემა:
თქვენი ამოცანაა გააკეთოთ მონეტის აგდების სიმულაციები და დათვალოთ საშუალოდ
რამდენჯერ უნდა ავაგდოთ მონეტა რათა 3-ჯერ ზედიზედ ამოვიდეს ბორჯღალო.

## ამოხსნა:
პირველ რიგში ჩვენი პრობლემა დავყოთ რამდენიმე ნაწილად:
* დავითვალოთ ერთი ექსპერიმენტის დროს, რამდენ აგდებაში მოვა ბორჯღალო.
* ასეთი ექსპერიმენტი ჩავატაროთ მუდმივა `numExperiments` რაოდენობაჯერ. 
* ავჯამოთ მიღებული შედეგები და გავყოთ ექსპერიმენტების რაოდენობაზე.

---

### მომზადება პრობლემის გადასაჭრელად
უმჯობესი იქნება თუ ექსპერიმენტების რაოდენობასა და ზედიზედ მოსული ბორჯღალოების რაოდენობას `private static final`
ცვლადებად გავიტანთ. შედეგად, მარტივად შეგვეძლება კოდში სურვილის მიხედვით ცვლილებების შეტანა.

---

### დეკომპოზიციური სურათის აგება
`for` ციკლით, შეგვიძლია ექსპერიმენტების რაოდენობაჯერ ავჯამოთ `simulation` ფუნქციის მიერ დაბრუნებული მნიშვნელობა, რომელიც, როგორც ზემოთ აღვწერე, ერთ ექსპერიმენტს ჩაატარებს და დააბრუნებს, რამდენ აგდებაში მოვიდა `numheads` ბორჯღალო ზედიზედ. ამის შემდეგ გავყოთ მიღებული ჯამი ექსპერიმენტების რაოდენობაზე. მივიღებთ კოდს:

```java
	private double avrgTosses(int numHeads, int numExperiments) {
		int average = 0;
		for (int i = 0; i < numExperiments; i++) {
			average += simulation(numHeads);
		}

		return (double) average / numExperiments;
	}
```

---

### `simulation` ფუნქციის იმპლემენტაცია
პირველ რიგში დავფიქრდეთ, რა ცვლადები დაგვჭირდება. აუცილებლად დაგვჭირდება შევინახოთ მონეტის აგდებების რაოდენობა. დავარქვათ მას `flips`. როგორმე უნდა დავიმახსოვროთ, თუ რამდენჯერ მოვიდა ზედიზედ ბორჯღალო. ამისთვის მეორე ცვლადი დაგვჭირდება, რომელსაც `heads` დავარქმევ. ჩვენ მანამდე უნდა "ავაგდოთ" მონეტა სანამ `heads` ცვლადი 3-ის ტოლი არ გახდება. ამისთვის გამოვიყენოთ `while` ციკლი. მონეტის აგდების სიმულაციის ერთ-ერთი და ალბათ ყველაზე მარტივი გზაა `RandomGenerator`-ის ფუნქციის `nextBoolean()`-ის საშუალებით შემთხვევითად დავაგენერიროთ `boolean`. დაგვიბრუნებს true-ს ან false-ს თანაბარი ალბათობით. პირობითად შეგვიძლია true ავიღოთ ბორჯღალოს მოსვლად, ხოლო false - არიოლად. 
რამდენჯერად ბორჯღალო მოვა გავზარდოთ `heads` ცვლადი. არ დაგვავიწყდეს, რომ თუ არიოლი მოვიდა `heads` უნდა გავანულოთ, ანუ ექსპერიმენტი ფაქტობრივად თავიდან იწყება. მივიღებთ კოდს: 

```java
private int simulation(int numHeads) {
		int heads = 0; 
		int flips = 0;
		while (heads != numHeads) {
			boolean flip = rand.nextBoolean();
			if (flip) {
				heads++;
			} else {
				heads = 0;
			}
			flips++;
		}

		return flips;
	}
```

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
> მთავარი ხარვეზი, რაც შეიძლება დავუშვათ ამოხსნისას, არის არიოლის მოსვლისას ექსპერიმენტის ჩვეულებრივად გაგრძელება `heads` ცვლადის განულების გარეშე. მივიღებთ არასწორ შედეგს.


## ალტერნატიული ამოხსნა
> ამოხსნაში შეგვიძლია მონეტის აგდების სიმულაცია მოვახდინოთ სხვანაირად. `boolean`-ის დაგენერირების ნაცვლად შეგვიძლია
სიმეტრიულ ინტერვალში დავაგენერიროთ რიცხვი და თუ პირველ ნახევარში ჩავარდა პირობითად ბორჯღალოდ ავიღოთ, თუ მეორეში -არიოლად. ასევე `flips` ცვლადის ნაცვლად შეგვიძლია 3 `boolean` ცვლადი გვქონდეს, თუმცა ასეთ შემთხვევაში კოდის შეცვლის სურვილი თუ გვექნება(ვთქვათ, გადავწყვიტეთ დავითვალოდ საშუალოდ 4 ბორჯღალო რამდენ აგდებაში მოდის) უფრო გაგვიჭირდება. 
