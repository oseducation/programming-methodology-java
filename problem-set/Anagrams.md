# Anagrams

პრობლემა:
```
დაწერეთ მეთოდი, რომელსაც გადაეცემა ორი სტრინგი და აბრუნებს true-ს თუკი ეს ორის
სტრინგი ერთმანეთის ანაგრამაა, ხოლო წინააღმდე შემთხვევაში აბრუნებს false-ს. ჩათვალეთ,
რომ ორივე სტრინგი მხოლოდ ლათინური ალფავიტის პატარა ასოებისგან შედგება.
იმპლემენტაცია გააკეთეთ მასივების გამოყენებით შემდეგი ალგორითმით: თითოეული
სიტყვისთვის დათვალეთ თითოეული სიმბოლოს რაოდენობა(‘a’-‘z’) და შეინახეთ მასივში.
შემდეგ შეადარეთ ერთმანეთს მასივები.
```

## პრობლემის გადაჭრის გზა
პირველ რიგში ჩვენი პრობლემა დავყოთ ორ ძირითად ნაწილად:
* თითოეული სტრინგისათვის შესაბამისი სიმბოლოების სიხშირის მასივის შედგენა
* შექმნილი მასივების საფუძველზე საბოლოო პასუხის დადგენა
---

### მასივის შედგენა თითოეული სტრინგისათვის
ვინაიდან, სტრინგი მხოლოდ პატარა ლათინური სიმბოლოებისაგან შედგება, შეგვიძლია შევქმნათ
26 სიგრძის მასივი, რომელშიც თითოეულ ინდექსზე შევინახავთ სიმბოლოების რაოდენობას სტრინგში.
მაგალითად: შემოგვდის `accdcz`. ამის შემდეგ გადავუყვეთ სტრინგს და კონკრეტული სიმბოლოსათვის გამოვთვალოთ
მისი ინდექსი მასივში, რომელიც იქნება `ch - 'a'` (ch არის ის სიმბოლო, რომელსაც ამ მომენტში განვიხილავთ).
გამოთვლილ ინდექსზე მასივის მნიშვნელობა გავზარდოთ 1-ით. მასივი საბოლოოდ მიიღებს შემდეგ სახეს:

![Image Of arr](/problem-set/images/anagrams.png)

ანალოგიურად შევადგენთ სიმბოლოების სიხშირეთა მასივს მეორე სტრინგისთვის.

### Anagrams OR Not Anagrams
ახლა, როდესაც ორივე სტრინგისათვის შედგენილი გვაქვს მასივები, რჩება მათ საფუძველზე პასუხის დადგენა - არიან თუ
არა შემოსული სტრინგები ერთმანეთის ანაგრამები. ორი სტრინგი ერთმანეთის ანაგრამა იქნება მხოლოდ იმ შემთხვევაში,
თუ მათი სიხშირეთა მასივები იდენტურია, ვინაიდან ერთი სტრინგიდან შეგვეძლება სიმბოლოები ისე გადავანაცვლოთ,
რომ მივიღოთ მეორე.
ამის შესამოწმებლად გადავუყვეთ ორივე მასივს და შევადაროთ თითოეულ ინდექსზე არსებული მნიშვნელობები. 
თუ ერთგან მაინც არ დაემთხვევა ეს მნიშვნელობები, ნიშნავს,
რომ შემოსული სტრინგები ერთმანეთის ანაგრამები არ არიან.

შესაბამისად, მივიღებთ კოდს:
```java
 private boolean isAnagram(String s1, String s2) {
    /*  Some code to count char frequencies . . . */
    for (int i = 0; i < NUM_CHARS; i++) {
        if (arr1[i] != arr2[i]) {
            return false;
        }
    }
    return true;
}
```

ამ ფუნქციისგან დაბრუნებული მნიშვნელობის მიხედვით, შეგვიძლია `run()`-ში დავბეჭდოთ საბოლოო პასუხი.

---

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
* იმისათვის, რომ გქონდეთ უფრო მეტად _clean code_, საჭიროა აირიდოთ ყველა _magic number_, 
რაც გულისხმობს იმას, რომ კოდში არ გამოიყენოთ რიცხვები, რომლებიც შესაძლოა ერთი შეხედვით გაუგებარი იყოს.
ამ ამოცანაში, "მაგიური რიცხვის" - *26*, ასარიდებლად შევქმენი კონსტანტა *NUM_CHARS*, რომელიც უკეთ გამოხატავს
მის დანიშნულებას.