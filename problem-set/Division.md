# Division
პრობლემა:
```
კარელმა უნდა გაყოს ორი რიცხვი, 2x1 უჯრაზე დევს n ცალი ბრილიანტი, 3x1 უჯრაზე m
ცალი ბრილიანტი, კარელმა 4x1 უჯრაზე უნდა დადოს n / m ბრილიანტი. ჩათვალეთ, რომ n
ზუსტად იყოფა m-ზე და კარელს ჩანთაში უსასრულო რაოდენობის ბრილიანტი აქვს.
```
##ამოცანის ამოხნის ალგორითმი
ჩვენი ამოცანა შეიცავს რამდენიმე რთულ ნაწილს. იმისათვის, რომ მეორე უჯრაზე დადებული ბრილიანტები გავყოთ მესამე უჯრაზე არსებულთან, ამისათვის
მესამე უჯრაზე დალაგებული ბრილიანტები იმდენჯერ უნდა გამოვაკლოთ მეორე უჯრაზე მყოფ ბრილიანტებს, სადამდეც შეგვიძლია. ამისათვის გვჭირდება ისეთი
უჯრა სადაც შევინახავთ ამ ოპერაციების რაოდენობას. ეს იყოს მეოთხე უჯრა. ამ უჯრაზე ყოველი გამოკლების ოპერაციის შემდეგ დავდოთ ბრილიანტი. საბოლოოდ
ეს მოგვცემს შედეგს.
## პრობლემის გადაჭრის გზა
ჩვენი ამოცანა მოიცავს სამ ძირითად ნაწილს და აუცილებელია განვიხილოთ თითოეული წარმატების მისაღწევად.
* კარელი უნდა გადავიდეს მესამე უჯრაზე და დაიწყოს გამოკლების ოპერაცია მეორე და მესამე უჯრებისთვის.
* ყოველ ოპერაციაზე გავზარდოთ მეოთხე უჯრაზე დალაგებული ბრილიანტები რაც საბოლოოდ მოგვცემს შედეგს.
* დააბრუნოს მეხუთე უჯრაზე დალაგებული ბრილიანტები მესამე უჯრაზე მოქმედების თავიდან დაწყებისთვის.
* ამ 2 მოქმედების შემდეგ, ბრილიანტები იქნება დალაგებული მესამე და მეოთხე უჯრაზე, ჩვენ გვჭირდება რომ ავიღოთ ყველა ბრილიანტი მესამე უჯრიდან, რათა ამოცანის პირობა სრულყოფილად დავიცვათ.
---
### გამოკლების ოპერაცია მეორე და მესამე უჯრებისთვის.
1. გამოვიყენოთ კარელისათვის ცნობილი `beepersPresent()` მეთოდი.
2. გამოვიყენოთ `while` ციკლი.
3. მესამე უჯრაზე დალაგებულ ბრილიანტების გამოკლების პარალელურად, მან მესამე უჯრაზე დაწყობილი ბრილიანტები უნდა შეინახოს მეხუთე უჯრაზე, რათა გამყოფი არ დაეკარგოს. როდესაც სრულად გამოაკლებს ბრილიანტებს,ამის შემდეგ მან შედეგი უნდა გაზარდოს ერთი ბრილიანტით მეოთხე უჯრაზე. ამას იმდენჯერ გააკეთებს რამდენჯერაც მოთავსდება m n-ში. (m-მესამე უჯრაზე დალაგებული ბრილიანტები, n-მეორე უჯრაზე დალაგებული ბრილიანტები)
შესაბამისად, მივიღებთ კოდს:
```java
while (beepersPresent()) {
	subtractOperation();
}
```
```java 
pickBeeper();
turnAround();
move();
pickBeeper();
turnAround();
move();
move();
move();
putBeeper();
turnAround();
move();
move();
turnAround();
```
> *როდესაც მესამე უჯრაზე აღარ აღმოჩნდება ბრილიანტები, `beepersPresent()` მეთოდი `while` ციკლს შეატყობინებს, რომ ამ უჯრაზე აღარ არის ბრილიანტები და კარელი გააკეთებს სხვა სვლას (ციკლი დასრულდება).*
---
### საბოლოო შედეგის გაზრდა და თანდათანობითი გამოთვლა მეოთხე უჯრაზე.
1. ყოველი გამოკლების ოპერაციის შესრულების შემდეგ კარელმა ბრილიანტი უნდა დადოს მეოთხე უჯრაზე,
საბოლოო პასუხის გამოსათვლელად.
```java
move();
putBeeper();
move();
```
### მეხუთე უჯრაზე დალაგებული ბრილიანტების მესამე უჯრაზე დაბრუნება
ახლა,როდესაც კარელმა წარმატებით გამოაკლო მესამე უჯრაზე მყოფი ბრილიანტები მეორე უჯრაზე მყოფს, მან უნდა დაიწყოს ეს ოპერაცია თავიდან, გვახსოვდეს რომ ეს უნდა გაკეთდეს იმდენჯერ სანამ მეორე უჯრაზე მყოფი ბრილიანტები სრულიად არ დაიცლება. ამისათვის მეხუთე უჯრაზე შენახულ ბრილიანტებს დავაბრუნებთ მესამე უჯრაზე.
1. გამოვიყენოთ კარელისათვის ცნობილი `beepersPresent()` მეთოდი.
2. გამოვიყენოთ `while` ციკლი.
შესაბამისად, მივიღებთ კოდს:
```java
while (beepersPresent()) {
	pickBeeper();
	turnAround();
	move();
	move();
	putBeeper();
	turnAround();
	move();
	move();
}
```
### დაბრუნდეთ მეორე უჯრაზე, რათა გამოკლების ოპერაცია თავიდან დავიწყოთ და ამოვწუროთ ამ უჯრაზე დალაგებული ბრილიანტების რაოდენობა
```java
turnAround();
move();
move();
move();
turnAround();
```
### მესამე უჯრაზე ბრილიანტების აღება და საბოლოო პასუხის დაფიქსირება
ამ ეტაპისთვის ჩვენ უკვე დავალაგეთ მეოთხე უჯრაზე ბიპერების ის რაოდენობა, რომელიც სწორ პასუხს შეესაბამება, რადგან ჩვენ ზუსტად იმდენჯერ გამოვაკელით მეორე უჯრაზე მყოფ ბრილიანტებს, მესამე უჯრაზე მყოფი, რამდენჯერაც მოთავსდა. საბოლოო პასუხის დასაფიქსირებლად გვჭირდება, მესამე უჯრიდან ავკრიფოთ დარჩენილი ბრილიანტები, რათა **მხოლოდ მეოთხეზე** დარჩეს სწორი პასუხი.
1. გამოვიყენოთ კარელისათვის ცნობილი `beepersPresent()` მეთოდი.
2. გამოვიყენოთ `while` ციკლი.
შესაბამისად, მივიღებთ კოდს:
```java
move();
while (beepersPresent()) {
	pickBeeper();
}
```
## რატომ დაგვჭირდა ამდენი მოქმედება მხოლოდ ერთი გამოკლების ოპერაციისთვის?
* ამოცანას ართულებს ის ფაქტი, რომ ჩვენ ჩანთაში უსასრულო რაოდენობის ბიპერები გვაქვს, და ვერ შეძლებს ჩვენი რობოტი კარელი, ზუსტად დაითვალოს, რამდენი ბრილიანტი აიღო ან დადო გარკვეულ უჯრაზე. ამისათვის დაგვჭირდა მეხუთე უჯრაზე ბრილიანტების შენახვის ოპერაცია, რომელიც ჩემი აზრით ერთ-ერთი საკვანძო მოქმედებაა ამ ამოცანაში.
---
## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
პირველ რიგში, მინდა მოგილოცოთ პროგრამის წარმატებით დასრულება და იმპლემენტაცია. რა თქმა უნდა თითოეულ ჩვენგანს შეუძლია ამ ამოცანის ამოხსნის ლოგიკის პოვნა, თუმცა მნიშვნელოვანია არ აგვერიოს თუ სად დგას და საით იყურება კარელი თითოეული მოქმედების დასრულების შემდეგ. ეს მნიშვნელოვანია,რადგან ციკლებმა გამართულად იმუშაოს.


