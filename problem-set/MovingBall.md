# MovingBall

პრობლემა:
```
დაწერეთ პროგრამა სადაც იქნება კანვასზე ბურთის მოძრაობა მარცხენა კედლის შუა
წერტილიდან მარჯვენა კედლამდე.
```


## პრობლემის გადაჭრის გზა

პირველ რიგში ჩვენი პრობლემა დავყოთ ორ ნაწილად
* ბურთის დახატვა კანვასის მარცხენა კედლის შუაში
* ბურთის მოძრაობა მარჯვენა კედლამდე

სანამ ბურთს დავხატავთ, მანამდე განვსაზღვროთ ის კონსტანტები, რომლებიც შემდეგ დაგვჭირდება, მაგალითად ბურთის დიამეტრი ან რადიუსი, მისი სიჩქარე და პაუზის დრო.
```java
private final static int DIAMETER = 100;
private final static int VELOCITY = 5;
private final static int PAUSE_tIME = 10;
```
ამ ცვლადების კონსტანტებად ჩაწერა დაგვეხმარება, ადვილად შევცვალოთ მათი მნიშვნელობები, თუ საჭირო გახდა.


### ბურთის დახატვა კანვასის მარცხენა კედლის შუაში

ჩვენი მიზანია, დავწეროთ `drawBall()` მეთოდის იმპლემენტაცია, რომელიც დააბრუნებს GOval ობიექტს (შემდეგ ამ ობიექტს გადავცემთ მეთოდს, რომელიც მის მოძრაობას უზრუნველყოფს).

ბურთის კანვასზე დახატვისთვის მთავარი ამოცანაა მისი საწყისი კოორდინატების დადგენა. რადგან მისი საწყისი მდებარეობა მარცხენა კედელთან უნდა იყოს, ბურთის x კოორდინატი იქნება 0, სურათზე კი გამოთვლილია მისი y კოორტინატი.

![This is an image](/problem-set/images/MovingBall-StartingPosition.png)

მეთოდს კი საბოლოო ჯამში ექნება შემდეგი სახე:

```java
private GOval drawBall() {
    GOval circle = new GOval(DIAMETER, DIAMETER);
    circle.setFilled(true);
    add(circle, 0, getHeight() / 2.0 - DIAMETER / 2.0);
    return circle;
}
```

### ბურთის მოძრაობა მარჯვენა კედლამდე

ახლა კი უნდა დავწეროთ `private void move(GOval circle)` მეთოდის იმპლემენტაცია, რომელიც ბურთს მარჯვენა კედლამდე მიიყვანს.

იმისათვის, რომ ბურთი მარჯვნივ გადავაადგილოთ, ვიყენებთ `move(double dx, double dy)` მეთოდს. ჩვენს შემთხვევაში dx წინასწარ შერჩეული სიჩქარეა, რომელიც კონსტანტად გავიტანეთ, ხოლო dy 0-ია, რადგან მხოლოდ x ღერძის გასწვრივ მოძრაობა გვჭირდება.
თუ `move(double dx, double dy)` და `pause(double milliseconds)` მეთოდებს `while()` ციკლში ჩავსვამთ მივიღებთ შემდეგ კოდს:
```java
private void move(GOval circle) {
    while (true) {
        circle.move(VELOCITY, 0);
        pause(PAUSE_tIME);
    }
}
```
თუმცა ეს ჯერ არ არის ჩვენი ამოცანის ამოხსნა, რადგან ბურთი მუდმივად მარჯვნივ იმოძრავებს და გაცდება ფანჯრის კიდეს.
იმისათვის, რომ როცა მარჯვენა კედელს შეეხება, გაჩერდეს, სულ უნდა ვამოწმოთ ბურთის x კოორდინატი `getX()` მეთოდით. თუ `circle.getX() >= getWidth() - DIAMETER`, ეს ნიშნავს, რომ ბურთი მარჯვენა კედელს შეეხო ან გასცდა და საჭიროა გაჩერდეს.

![This is an image](/problem-set/images/MovingBall-FinalPosition.png)

ამიტომ ჩვენს ციკლში უნდა ჩავამატოთ:
```java
if (circle.getX() >= getWidth() - DIAMETER)
    break;
```


## რატომ იმუშავებს კოდი ფანჯრის ნებისმიერი ზომისათვის?

როგორც ვხედვთ, ჩვენ მიერ დაწერილ კოდში ვიყენებთ დინამიკურ მონაცემებს - ვიძახებთ `getHeight()`/`getWidth()` მეთოდებს, რის გამოც პროგრამა სწორად იმუშავებს ნებისმიერი ზომის ფანჯრისთვის.


## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას

ერთ-ერთი ხშირად დაშვეული შეცდომა ის არის, რომ if (circle.getX() **==** getWidth() - DIAMETER)-ს წერენ **>=**-ს მაგივრად. ამ შემთხვევაში დიდია იმის ალბათობა, რომ ბურთი არ გაჩერდება კედელთან შეხების დროს და გააგრძელებს მოძრაობას. საქმე ისაა, რომ შესაძლოა circle.getX() და getWidth() - DIAMETER არასოდეს არ დაემთხვეს ერთმანეთს, გააჩნია როგორი სიჩქარით ვამოძრავებთ ბურთს და რა სიგანე აქვს ფანჯარას. ამიტომ საჭიროა თავის დაზღვევის მიზნით დავწეროთ >= ნიშანი. თუ ჩვენ მიერ დაწერილი კოდის მუშაობას დააკვირდებით, შეამჩნევთ კიდეც რომ ბურთი ზუსტად მაშინ არ ჩერდება, როცა კედელს ეჯახება და ცოტათი ცდება.
