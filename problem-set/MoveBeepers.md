# MoveBeepers

## პრობლემა:

ცარიელ სამყაროში კარელი დგას **1x1** უჯრაზე. **5x1** უჯრაზე დევს **10** ცალი ბრილიანტი, კარელმა ათივე ბრილიანტი უნდა გადაიტანოს **6x1** უჯრაზე.

## პრობლემის გადაჭრის გზა:

პირველ რიგში, გადავიყვანოთ კარელი **4** უჯრით მარჯვნივ და დავაყენოთ **5x1** უჯრაზე, შემგედ ავაღებინოთ მას **10** ბრილიანტი, კიდევ **1** უჯრით გადავიყვანოთ მარჯვნივ **6x1** უჯრაზე და დავადებინოთ ათივე ბრილიანტი.

## პრობლემის გადაჭრის გზის კოდად გარდაქმნა:

1. თავდაპირველად, როგორც ვთქვით, გვჭირდება კარელი დავაყენოთ **5x1** უჯრაზე, ამისათვის საჭიროა ის **4** ნაბიჯით გადავიყვანოთ მარჯვნივ. როგორც ვიცით, კარელი დასაწყისშივე აღმოსავლეთით იხედება, ამიტომ თუ გამოვიყენებთ **move()** მეთოდს, ეს მას ერთი უჯრით მარჯვნივ გადაიყვანს და **2x1** უჯრაზე დააყენებს. იმისათვის, რომ კარელი **5x1** უჯრაზე მოხვდეს, დაგვჭირდება, რომ **move()** მეთოდი **4** ჯერ გამოვიძახოთ. შეგვიძლია **move()** ოთხჯერ დავწეროთ და კარელიც ოთხ ნაბიჯს გადადგამს, თუმცა უფრო ეფექტური იქნება, თუ **for** ციკლს გამოვიყენებთ. შესაბამისად, მივიღებთ კოდს:
```java	
	for (int i = 0; i < 4; i++) {
			move();
	}
```

2. ამ ეტაპზე კარელი **5x1** უჯრაზე იმყოფება, სადაც **10** ბრილიანტი დევს. ბრილიანტის ასაღებად გამოვიყენებთ **pickBeeper()** მეთოდს. ამ მეთოდის ერთხელ გამოძახებით კარელი ბრილიანტების გროვიდან ერთ ბრილიანტს აიღებს, მაშასადამე **pickBeeper()** მეთოდის გამოძახება ათჯერ მოგვიწევს. ამის გაკეთება შეგვიძლია **pickBeeper()**-ის ათჯერ დაწერით, თუმცა ამ შემთხვევაშიც შეგვიძლია კოდის ზომა საგრძონბლად შევამოკლოთ და **for** ციკლი გამოვიყენოთ. მივიღებთ კოდს:
```java	
	for (int i = 0; i < 10; i++) {
			pickBeeper();
	}
```

3. ახლა, როცა კარელს ათივე ბრილიანტი უჭირავს, ერთი **move()** მეთოდია იმისათვის საჭირო, რომ ის **6x1** უჯრაზე დადგეს, სადაც აღებული ათი ბრილიანტი უნდა დაალაგოს.

4. ბრილიანტის დასადებად საჭირო მეთოდი არის **putBeeper()**, რომლის ერთხელ გამოძახებით კარელი იმ უჯრაზე ერთ ბრილიანტს დებს, რომელზეც ამ მომენტში დგას. ამ შემთხევაშიც, ათივე ბრილიანტი უნდა მოვათავსოთ **6x1**-ზე, ამიტომ აქაც **fo**r ციკლს გამოვიყენებთ შემდეგნაირად:
```java	
	for (int i = 0; i < 10; i++) {
			putBeeper();
	}
```

## რატომ ვიყენებთ for ციკლს?

1. **for** ციკლი ჩვენ შემთხვევაში ყველაზე ხელსაყრელი აღმოჩნდა, რადგან თითოეული მოქმედება რამდენჯერ უნდა შეგვესრულებინა წინასწარ ვიცოდით. ვიცოდით, რომ კარელს ოთხი ნაბიჯი უნდა გადაედგა, ამიტომ პირველი ციკლი ოთხჯერ დავატრიალეთ, ვიცოდით, რომ ბრილიანტი ათჯერ უნდა აეღო, ამიტომ მეორე ციკლი ათჯერ დავატრიალეთ და ბოლოსაც ვიცოდით, რომ ათივე ბრილიანტი უნდა დაგვედო, ამიტომ ბოლო ციკლიც ათჯერ დავატრიალეთ. 

2. როგორც ზემოთ ავღნიშნე, თუ არ გამოვიყენებდით რაიმე ციკლს, კოდი დიდი ზომის გამოვიდოდა, რადგან მოგვიწევდა კარელის თითოეული მოქმედებისთვის ახალ ხაზზე ახალი მეთოდი დაგვეწერა, რაც არ იქნებოდა ეფექტური.

## შესაძლო ხარვეზები:

1. პირობაში ნათქვამია, რომ კარელი თავდაპირველად **1x1** უჯრაზეა და **5x1**-ზე უნდა გადავიდეს, ეს იმას არ ნიშნავს, რომ კარელმა ხუთი ნაბიჯი უნდა გადადგას. შემდეგი კოდის გამოყენება შეცდომა იქნებოდა:
```java	
	for (int i = 0; i < 5; i++) {
			move();
	}
```
ამ შემთხევაში, კარელი ხუთი უჯრით მარჯვნივ აღმოჩნდებოდა **6x1** უჯრაზე.

