# Sum1N

პრობლემა:
```
მომხმარებელს შეყავს მთელი რიცხვი n, პროგრამამ უნდა დაბეჭდოს 1 დან n მდე რიცხვების
ჯამი

```



## პრობლემის გადაჭრის გზა:
ამოცანის ამოსახსნელად, საჭიროა, 3 ეტაპი:
 *მომხმარებელმა უნდა შემოიტანოს რიცხვი n;
 *პროგრამამ უნდა დათვალოს ჯამი 1 დან n მდე ნატურალური რიცხვებისა.
 *პროგრამამ უნდა დაპრინტოს ინფორმაცია კონსოლში.




---

### I.მომხმარებლის მიერ შემოტანილი ინფორმაციის წაკითხვა:
 * მომხმარებელმა კონსოლში უნდა შემოიტანოს რიცხვი n, რასაც ვაკეთებთ readInt() მეთოდის მეშვეობით. იმისათვის, რომ ჩვენს კონსოლის პროგრამას გასაგები ინტერფეისი ჰქონდეს, readInt()-მეთოდს ფრჩხილებში გადავცემთ არგუმენტს, ანუ იმას თუ რა უნდა დაპრინტოს პროგრამამ, ვიდრე მომხმარებელი შემოიყვანს რიცხვს (n-ს). საბოლოოდ მივიღებთ readInt("Enter n: "); სინტაქსს. readInt მეთოდი გვიბრუნებს იმ რიცხვის (int-ტიპის) მნიშვნელობას, რომელიც მომხმარებელმა შემოიტანა და, შესაბამისად, ვინახავთ მას num ცვლადში. შესაბამისად, მივიღეთ კოდი : int num = readInt("Enter n: ");

### II.ჯამის დათვლა 1 დან n მდე ნატურალური რიცხვებისა:
 * ცხადია, ჯამის დათვლა რამდენიმენაირად შეგვიძლია, თუმცა ყველაზე მარტივი და ინტუიტიური მაინც ფორმულის გამოყენებაა მათემატიკიდან. 1 დან n-მდე რიცხვების ჯამი მოიცემა ფორმულით ( n*(n+1) ) / 2 -ს, რომლის გამოყვანაც შეგვიძლია არითმეტიკული პროგრესიის ჯამის ფორმულიდან -> (A(1)+A(n))*n /2. ხოლო ჩვენ შემთხვევაში n-ის მაგივრად გვქენება num-ცვლადი და შესაბამისად მიღებულ მნიშვნელობას შევინახავთ sumFormula ცვლადში.


### III. მიღებული შედეგის დაპრინტვა კონსოლში:
 * კონსოლში შედეგის დასაბეჭდად, ვიყენებთ მეთოდს println()-ს, ხოლო არგუმენტად გადავცემთ დასაპრინტ მესიჯს. როგორც ვხედავთ, მესიჯი არ შეიცავს მხოლოდ გამზადებულ ტექსტს (string-ს), არამედ ჩვენს მიერ გამოყოფილ ცვლადსაც (sumFormula-ს), იმისათვის, რომ ეს მესიჯი გავაერთიანოთ და println-მა მიიღოს ჩვენი არგუმენტი, ვიყენებთ + ოპერატორს და ჯავას კომპილატორი თვითონ ხვდება, რომ sumFormula, რომელიც int ტიპისაა, string-ში გადაიყვანოს. ამიტომ ჩვენი მიღებული მესიჯია: "Sum of first n natural numbers is: " + sumFormula. ხოლო საბოლოოდ ვიღებთ შემდეგ კოდს : println("Sum of first n natural number is: " + sumFormula); ამის შემდეგ პროგრამა დაბეჭდავს 1 დან მომხმარებლის შეყვანილ რიცხვამდე ნატურალურ რიცხვთა ჯამს.

---

## რატომ იმუშავებს კოდი ნებისმიერი n-თვის?
 * პირველ რიგში, უნდა აღინიშნოს, რომ საკმარისად დიდი n-თვის კოდი არ იმუშავებს, რადგან მიღებულ ჯამს ვინახავთ int - ტიპის ცვლადში და int ტიპის მაქსიმალური მნიშვნელობის გადაცილების შემდგომ, ცხადია, მივიღებთ არასწორ ჯამს. ამ პრობლემას ვერ გადავჭრით, მაქსიმუმ რაც შეგვიძლია, რომ გავაკეთოთ, არის უფრო დიდი ინტერვალის მქონე ტიპში შევინახოთ, თუმცა ცხადია, ამ ტიპისთვისაც იარსებებს საკმარისად დიდი n-რომელიც გადააჭარბებს მის მაქსიმალურ მნიშვნელობასაც, ამიტომ სიმარტივისთვის ვინახავთ int ტიპში და მხოლოდ და მხოლოდ იმ შემთხვევაში გამოვიყენებთ სხვა ტიპს თუ მართლაც დიდ რიცხვებზე გვიწევს მუშაობა. თვითონ ფორმულის გამოყვანა როგორც ვნახეთ შეგვიძლია არითმეტიკული პროგრესიის ჯამის მიხედვით, (A(1)+A(n))*n/2 , ჩვენი არითმეტიკული პროგრესია შემდეგი ტიპისაა : 1,2,3....n, შესაბამისად, A(1)=1 და A(n) = n, ეს მნიშნველობები რომ ჩავსვათ არითმეტიკული პროგრესიის ჯამის ფორმულაში მივიღებთ, რომ ჯამი 1 დან n-მდე(ჩათვლით) ნატურალური რიცხვებისა უდრის (n*(n+1))/2, შესაბამისად ფორმულა მართებულია ნებისმიერი ნატურალური n-სთვის. რაც გვიჩენს ერთ კითხვას, რა მოხდება, თუკი მომხმარებელი n-ის ნაცვლად შემოიტანს არა ნატურალურ რიცხვს:


### პრობლემა N1: n-არ არის ნატურალური:
 * შევნიშნოთ, რომ ჩვენ მომხმარებლის მიერ შემოტანილი რიცხვის წასაკითხად ვიყენებთ მეთოდს readInt()- რომელიც Int-რიცხვს კითხულობს და თუკი შემოტანილი რიცხვი Int ტიპის არ აღმოჩნდა, ამ შემთხვევაში კონსოლზე დაგვიპრინტავს გაწითლებულად [Illegal numeric format] და სთხოვს მომხმარებელს, რომ თავიდან შემოიტანოს ინფორმაცია. თუმცა გვრჩება კიდევ ერთი შემთხვევა, რომ n ნამდვილად ნატურალური იყოს, ამისათვის უნდა გამოვრიცხოთ არადადებითი რიცხვები, რომლებიც Int ტიპის range-ში (ინტერვალში) შედის. ამ პრობლემის აღმოსაფხვრელად, უნდა შევამოწმოთ თუ რა მნიშვნელობა ჩაიწერა num ცვალდში და მის მიხედვით ვიმოქმედოთ.
  ერთი ვარიანტია, რომ if-ის მეშვეობით შევამოწმოთ დადებითია თუ არა num-ცვლადი და თუ არ არის თავიდან ვთხოვოთ მომხმარებელს შემოიტანოს რიცხვი, და გვექნებოდა შემდეგნაირი კოდი : 

int num = readInt("Enter n: ");
if(num<=0){
  num = readInt("Enter n: ");
}...

 შევნიშნოთ, რომ თუკი მომხმარებელმა ხელმეორედ შემოიტანა არადადებითი რიცხვი, მაშინ ჩვენი პროგრამა num-ს აღარ შეამოწმებს დადებითია, თუ არა, რადგან if- ერთჯერადად იშვება, შესაბამისად, თუ გვინდა, რომ ყოველ შემოტანილ რიცხვზე შემოწმდეს num-ცვლადი მანამ სანამ არადადებითი რიცხვი არ შემოვა, უნდა გამოვიყენოთ while-ციკლი და if-ის while-თი ჩანაცვლებით მივიღებთ შემდეგ კოდს:

int num = readInt("Enter n: ");
while(num<=0){
  num = readInt("Enter n: ");
}...

 ამჯერად კოდი იმუშავებს სწორად, თუმცა რომ დავაკვირდეთ, readInt-მეთოდი ორჯერ გვიწერია იგივე დანიშნულებით, ხოლო ამის თავიდან ასაცილებლად, იმის მაგივრად, რომ readInt()-ით წავიკითხოთ მომხმარებლის მიერ შემოტანილი რიცხვი, შეგვიძლია, თავდაპირველად num ცვლადს მივანიჭოთ რაიმე არადადებითი რიცხვის მნიშვნელობა, შესაბამისად while-ციკლში ის შევა და ამის შემდეგ ციკლი იმუშავებს მანამ, სანამ num ცვლადი არ მიიღებს დადებითი რიცხვის მნიშვნელობას. საბოლოოდ გვექნება შემდეგი კოდი: 
int num = 0;
while(num<=0){
  num = readInt("Enter n: ");
}...


### გაფრთხილება : 
 * რომ დავაკვირდეთ, while-ციკლის შემდგომ მე-13 ხაზზე გვიწერია შემდეგი კოდი ( num*(num+1) ) / 2; გარეთა ფრჩხილები მეტი გასაგებობისთვისაა გამოყენებული, მიუხედავად იმისა, რომ გარეთა ფრჩხილების მოცილებით კოდი მაინც სწორად იმუშავებს. თუმცა უნდა აღინიშნოს, რომ მათემატიკაში არ აქვს მნიშვნელობა 2-ზე გაყოფას სად დავწერდით და მთლიან ნამრალვს გავყოფდით 2-ზე, თუ ერთ-ერთ რომელიმე წევრს, თუმცა ჯავაში (და ბევრ სხვა ენაში თუ ყველაში არა) ამას მნიშვნელობა აქვს, რადგან რომ დაგვეწერა შემდეგი გამოსახულება num/2 * (num+1)-ზე კენტი num-თვის პროგრამა არ იმუშავებდა რადგან დავუშვათ num=10-ის შემთხვევაში num/2=5 5.5-ის მაგივრად, რადგან ხდება int ტიპზე ოპერაცია, პასუხადაც int ტიპს ვიღებთ,ანუ 5-ს , პროგრამა იმ შემთხვევაში იმუშავებდა სწორად, თუკი ათწილადებსაც შემოვიღებდით num-ის შესაძლო მნიშვნელობებში, მაგალითად double-ს, ხოლო რადგანაც int ტიპებში ვმუშაობთ, ამიტომ მთლიან ნამრავლს ვყოფთ 2-ზე (შევნიშნოთ, რომ num*(num+1) ორი მომდევნო ნატურალური რიცხვის ნამრავლია, ამიტომ აუცილებლად ლუწი იქნება და პასუხი int ტიპისაა).

## პრობლემის გადაჭრის განსხვავებული ხერხი:
 * როგორც უკვე ვთქვით, არაერთნაირად შეგვიძლია ამ პრობლემის გადაჭრა, და მიუხედავად იმისა, რომ ჩვენ ავირჩიეთ მათ შორის ყველაზე მარტივი, განვიხილოთ კიდევ სხვა გზა. ფორმულის გამოყენების მაგივრად, შეგვიძლია პირდაპირ გადავუყვეთ თითოეულ რიცხვს 1 დან n-მდე და რიგ-რიგობით შევკრიბოთ, ანუ თავდაპირველად პირველი და მეორე რიცხვი, შემდეგ ეს ჯამი სადმე შევინახოთ და ამის შემდეგ ამ ჯამს დავუმატოთ მესამე რიცხვი, შემდეგ მეოთხე და ა.შ. რიცხვებს გადავუყვებით 1 დან n-მდე for-ციკლის მეშვეობით, თუმცა შეგვიძლია იგივეს გაკეთება while-ციკლითაც, ცხადია. ამიტომ გვექნებოდა შემდეგი კოდი: 

int num = 0;
while(num<=0){
  num = readInt("Enter n: ");
}
int sum = 0;
for(int i = 1; i<=num;i++){
 sum = sum+i;
}
println("Sum of first n natural numberss is: " + sum);

### რატომ ჩვენს მიერ არჩეული თავდაპირველი გზა?
 * იმიტომ, რომ ამ მეორე ტიპის ამოხსნას რომ დავაკვირდეთ გვიწევს num ჯერ დავუმატოთ sum- ცვლადს i-ური რიცხვი, განსხვავებით ჩვენი ორიგინალური ამოხსნისგან, სადაც მხოლოდ და მხოლოდ 1 ოპერაციაში (მათემატიკურად 3 ოპერაციაში, ჯამი, შემდეგ ნამრავლი და ბოლოს გაყოფა ორზე) ვიგებთ საბოლოო ჯამს და მიუხედავად იმისა, რომ პატარა num-თვის პროგრამა მაინც საკმაოდ სწრაფად მუშაობს, დაწყებული გარკვეული num-დან ჩვენს პროგრამას საგრძნობლად დიდი უპირატესობა ექნება დროში (ცხადია, თუ გავითვალისწინებთ იმას, რომ num არ გაცდეს შესაბამისი ტიპის საზღვრებს).

### აღნიშვნა:
 * ალბათ, შეამჩნევდით, რომ მიღებული ჯამის sumFormula-ცვლადში შენახვა არ არის საჭირო და შეგვეძლო პირდაპირ println() მეთოდში გადაგვეცა ის პლუსის შემდგომ, თუმცა იმისათვის, რომ კოდი უფრო წაკითხვადი იყოს, ვინახავთ sumFormula-ცვლადში, ამის შემდეგ, რომ დავხედოთ println()-მეთოდში ჩაწერილ არგუმენტს, ვხვდებით თუ რას აკეთებს ჩვენი პროგრამა, განსხვავებით იმ შემთხვევისგან, თუკი გვექნებოდა შემდეგი კოდი :
println("Sum of first n natural numbers is: " + (num*(num+1))/2);