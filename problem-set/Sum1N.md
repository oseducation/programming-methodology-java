# Sum1N

პრობლემა:
```
მომხმარებელს შეყავს მთელი რიცხვი n, პროგრამამ უნდა დაბეჭდოს 1 დან n მდე რიცხვების
ჯამი

```



## პრობლემის გადაჭრის გზა:
ამოცანის ამოსახსნელად, საჭიროა, 3 ეტაპი:
 *მომხმარებელმა უნდა შემოიტანოს რიცხვი n;
 *პროგრამამ უნდა დათვალოს ჯამი 1 დან n მდე ნატურალური რიცხვებისა.
 *პროგრამამ უნდა დაპრინტოს ინფორმაცია კონსოლში.

---

### I.მომხმარებლის მიერ შემოტანილი ინფორმაციის წაკითხვა:
 * მომხმარებელმა კონსოლში უნდა შემოიტანოს რიცხვი n, რასაც ვაკეთებთ readInt() მეთოდის მეშვეობით. იმისათვის, რომ ჩვენს კონსოლის პროგრამას გასაგები ინტერფეისი ჰქონდეს, readInt()-მეთოდს ფრჩხილებში გადავცემთ არგუმენტს, ანუ იმას თუ რა უნდა დაპრინტოს პროგრამამ, ვიდრე მომხმარებელი შემოიყვანს რიცხვს (n-ს). საბოლოოდ მივიღებთ readInt("Enter n: "); სინტაქსს. readInt მეთოდი გვიბრუნებს იმ რიცხვის (int-ტიპის) მნიშვნელობას, რომელიც მომხმარებელმა შემოიტანა და, შესაბამისად, ვინახავთ მას num ცვლადში. შესაბამისად, მივიღეთ კოდი : int num = readInt("Enter n: ");

### II.ჯამის დათვლა 1 დან n მდე ნატურალური რიცხვებისა:

 * შეგვიძლია პირდაპირ გადავუყვეთ თითოეულ რიცხვს 1 დან n-მდე და რიგ-რიგობით შევკრიბოთ, ანუ თავდაპირველად შევკრიბოთ პირველი და მეორე რიცხვი, შემდეგ ეს ჯამი სადმე შევინახოთ და ამის შემდეგ ამ ჯამს დავუმატოთ მესამე რიცხვი, შემდეგ მეოთხე და ა.შ. რიცხვებს გადავუყვებით 1 დან n-მდე for-ციკლის მეშვეობით, თუმცა შეგვიძლია იგივეს გაკეთება while-ციკლითაც, ცხადია. ამიტომ გვექნება შემდეგი კოდი:
```java
...

int sum = 0;
for(int i = 1; i < num;i++){
 sum = sum + i;
}
...

```
 


### III. მიღებული შედეგის დაპრინტვა კონსოლში:
 * კონსოლში შედეგის დასაბეჭდად, ვიყენებთ მეთოდს println()-ს, ხოლო არგუმენტად გადავცემთ დასაპრინტ მესიჯს. როგორც ვხედავთ, მესიჯი არ შეიცავს მხოლოდ გამზადებულ ტექსტს (string-ს), არამედ ჩვენს მიერ გამოყოფილ ცვლადსაც (sum-ს), იმისათვის, რომ ეს მესიჯი გავაერთიანოთ და println-მა მიიღოს ჩვენი არგუმენტი, ვიყენებთ + ოპერატორს და ჯავას კომპილატორი თვითონ ხვდება, რომ sum, რომელიც int ტიპისაა, string-ში გადაიყვანოს. ამიტომ ჩვენი მიღებული მესიჯია: "Sum of natural numbers untill n is: " + sum. ხოლო საბოლოოდ ვიღებთ შემდეგ კოდს : println("Sum of natural numbers untill n is: " + sum); ამის შემდეგ პროგრამა დაბეჭდავს 1 დან მომხმარებლის შეყვანილ რიცხვამდე ნატურალურ რიცხვთა ჯამს.

---

### პრობლემა N1: n-არ არის ნატურალური:
 * შევნიშნოთ, რომ ჩვენ მომხმარებლის მიერ შემოტანილი რიცხვის წასაკითხად ვიყენებთ მეთოდს readInt()- რომელიც Int-რიცხვს კითხულობს და თუკი შემოტანილი რიცხვი Int ტიპის არ აღმოჩნდა, ამ შემთხვევაში კონსოლზე დაგვიპრინტავს გაწითლებულად [Illegal numeric format] და სთხოვს მომხმარებელს, რომ თავიდან შემოიტანოს ინფორმაცია. თუმცა გვრჩება კიდევ ერთი შემთხვევა, რომ n ნამდვილად ნატურალური იყოს, ამისათვის უნდა გამოვრიცხოთ არადადებითი რიცხვები, რომლებიც Int ტიპის range-ში (ინტერვალში) შედის. ამ პრობლემის აღმოსაფხვრელად, უნდა შევამოწმოთ თუ რა მნიშვნელობა ჩაიწერა num ცვალდში და მის მიხედვით ვიმოქმედოთ.
  ერთი ვარიანტია, რომ if-ის მეშვეობით შევამოწმოთ დადებითია თუ არა num-ცვლადი და თუ არ არის თავიდან ვთხოვოთ მომხმარებელს შემოიტანოს რიცხვი, და გვექნებოდა შემდეგნაირი კოდი : 
```java

int num = readInt("Enter n: ");
if(num<=0){
  num = readInt("Enter n: ");
}...

```
 შევნიშნოთ, რომ თუკი მომხმარებელმა ხელმეორედ შემოიტანა არადადებითი რიცხვი, მაშინ ჩვენი პროგრამა num-ს აღარ შეამოწმებს დადებითია, თუ არა, რადგან if- ერთჯერადად იშვება, შესაბამისად, თუ გვინდა, რომ ყოველ შემოტანილ რიცხვზე შემოწმდეს num-ცვლადი მანამ სანამ არადადებითი რიცხვი არ შემოვა, უნდა გამოვიყენოთ while-ციკლი და if-ის while-თი ჩანაცვლებით მივიღებთ შემდეგ კოდს:
```java

int num = readInt("Enter n: ");
while(num<=0){
  num = readInt("Enter n: ");
}...

```
 ამჯერად კოდი იმუშავებს სწორად, თუმცა რომ დავაკვირდეთ, readInt-მეთოდი ორჯერ გვიწერია იგივე დანიშნულებით, ხოლო ამის თავიდან ასაცილებლად, იმის მაგივრად, რომ readInt()-ით წავიკითხოთ მომხმარებლის მიერ შემოტანილი რიცხვი ორჯერ, შეგვიძლია, while(true) ციკლში ვიმუშაოთ და სასურველი შედეგის მიღების შემდგომ break გავუკეთოთ. საბოლოოდ გვექნება შემდეგი კოდი:
```java

int sum = 0;
while(true){
  int num = readInt("Enter n: ");
  if(num > 0){
     for(int i = 1; i < num;i++){
       sum = sum + i;
     }
     break;
  }
}...

```

### გაფრთხილება :
 * უნდა აღვნიშნოთ, რომ n საკმარისად დიდი რიცხვი რომ შემოიყვანოს მომხმარებელმა, და ამასობაში ჩვენ ვკრიბოთ ყველა რიცხვი 1 დან n-მდე, რადგან sum ცვლადი int ტიპისაა და გააჩნია საკუთარი საზღვრები (ანუ მაქსიმალური და მინიმალური მნიშვნელობა), შესაძლოა, გადასცდეს int ტიპის ზღვარს და პასუხად არასწორი რიცხვი მივიღოთ, ამის თავიდან ასარიდებლად, შეგვიძლია, გამოვიყენოთ int ტიპის მაგივრად სხვა უფრო დიდი ინტერვალის მქონე ტიპი, მაგალითად, long , თუმცა ისიც უნდა აღვნიშნოთ, რომ long-საც გააჩნია საკუთარი ზღვარი და გარკვეული n-თვის უკვე არც long-ში არ ჩაეტევა ჩვენი ჯამის მნიშვნელობა. (აღსანიშნავია, რომ თუ n int-ტიპისაა, მაშინ ჯამი 1 დან n-ის მაქსიმალურ შესაძლო მნიშვნელობამდე ჩაეტევა long-ში, რისი დადასტურებაც შეგვიძლია პირდაპირ მაქსიმალური მნიშვნელობების ჩასმით და long-ის მაქსიმალურ მნიშვნელობასთან შედარებით, შესაბამისად, თუ n int-ტიპისაა, მსგავს პრობლემას ვერ შევხვდებით, თუკი sum-ცვლადი long-ტიპისაა).

## პრობლემის გადაჭრის განსხვავებული ხერხი:
 * ცხადია, ჯამის დათვლა რამდენიმენაირად შეგვიძლია, თუმცა ყველაზე მარტივი და ინტუიტიური მაინც ფორმულის გამოყენებაა მათემატიკიდან. 1 დან n-მდე რიცხვების ჯამი მოიცემა ფორმულით ( n*(n+1) ) / 2 -ს, რომლის გამოყვანაც შეგვიძლია არითმეტიკული პროგრესიის ჯამის ფორმულიდან -> (A(1)+A(n))*n /2. ხოლო ჩვენ შემთხვევაში n-ის მაგივრად გვქენება num-ცვლადი და შესაბამისად მიღებულ მნიშვნელობას შევინახავთ sumFormula ცვლადში: int sumFormula = (num*(num+1)) / 2;

## რატომ იმუშავებს კოდი ნებისმიერი n-თვის?
 * პირველ რიგში, როგორც უკვე ვთქვით,საკმარისად დიდი n-თვის კოდი არ იმუშავებს, რადგან მიღებულ ჯამს ვინახავთ int - ტიპის ცვლადში და int ტიპის მაქსიმალური მნიშვნელობის გადაცილების შემდგომ, ცხადია, მივიღებთ არასწორ ჯამს. ამ პრობლემას ვერ გადავჭრით, მაქსიმუმ რაც შეგვიძლია, რომ გავაკეთოთ, არის უფრო დიდი ინტერვალის მქონე ტიპში შევინახოთ, თუმცა ცხადია, ამ ტიპისთვისაც იარსებებს საკმარისად დიდი n-რომელიც გადააჭარბებს მის მაქსიმალურ მნიშვნელობასაც, ამიტომ სიმარტივისთვის ვინახავთ int ტიპში და მხოლოდ და მხოლოდ იმ შემთხვევაში გამოვიყენებთ სხვა ტიპს თუ მართლაც დიდ რიცხვებზე გვიწევს მუშაობა. თვითონ ფორმულის გამოყვანა, როგორც ვნახეთ, შეგვიძლია არითმეტიკული პროგრესიის ჯამის მიხედვით, (A(1)+A(n))*n/2 , ჩვენი არითმეტიკული პროგრესია შემდეგი ტიპისაა : 1,2,3....n, შესაბამისად, A(1)=1 და A(n) = n, ეს მნიშნველობები რომ ჩავსვათ არითმეტიკული პროგრესიის ჯამის ფორმულაში მივიღებთ, რომ ჯამი 1 დან n-მდე(ჩათვლით) ნატურალური რიცხვებისა უდრის    (n*(n+1))/2, შესაბამისად ფორმულა მართებულია ნებისმიერი ნატურალური n-სთვის.

### გაფრთხილება : 
 * რომ დავაკვირდეთ, while-ციკლის შემდგომ მე-13 ხაზზე გვიწერია შემდეგი კოდი ( num*(num+1) ) / 2; გარეთა ფრჩხილები მეტი გასაგებობისთვისაა გამოყენებული, მიუხედავად იმისა, რომ გარეთა ფრჩხილების მოცილებით კოდი მაინც სწორად იმუშავებს. თუმცა უნდა აღინიშნოს, რომ მათემატიკაში არ აქვს მნიშვნელობა 2-ზე გაყოფას სად დავწერდით და მთლიან ნამრალვს გავყოფდით 2-ზე, თუ ერთ-ერთ რომელიმე წევრს, თუმცა ჯავაში (და ბევრ სხვა ენაში თუ ყველაში არა) ამას მნიშვნელობა აქვს, რადგან რომ დაგვეწერა შემდეგი გამოსახულება num/2 * (num+1)-ზე კენტი num-თვის პროგრამა არ იმუშავებდა რადგან დავუშვათ num=11-ის შემთხვევაში num/2=5 5.5-ის მაგივრად, რადგან ხდება int ტიპზე ოპერაცია, პასუხადაც int ტიპს ვიღებთ, ანუ 5-ს, პროგრამა იმ შემთხვევაში იმუშავებდა სწორად, თუკი ათწილადებსაც შემოვიღებდით num-ის შესაძლო მნიშვნელობებში, მაგალითად double-ს, ხოლო რადგანაც int ტიპებში ვმუშაობთ, ამიტომ მთლიან ნამრავლს ვყოფთ 2-ზე (შევნიშნოთ, რომ num*(num+1) ორი მომდევნო ნატურალური რიცხვის ნამრავლია, ამიტომ აუცილებლად ლუწი იქნება და პასუხი int ტიპისაა).

### რატომ არის მეორე გზა პირველზე უმჯობესი?
 * იმიტომ, რომ პირველი ტიპის ამოხსნას რომ დავაკვირდეთ გვიწევს num ჯერ დავუმატოთ sum- ცვლადს i-ური რიცხვი, განსხვავებით ჩვენი მეორე ამოხსნისგან, სადაც მხოლოდ და მხოლოდ 1 ოპერაციაში (მათემატიკურად 3 ოპერაციაში, ჯამი, შემდეგ ნამრავლი და ბოლოს გაყოფა ორზე) ვიგებთ საბოლოო ჯამს და მიუხედავად იმისა, რომ პატარა num-თვის პროგრამა მაინც საკმაოდ სწრაფად მუშაობს, დაწყებული გარკვეული num-დან ჩვენს პროგრამას საგრძნობლად დიდი უპირატესობა ექნება დროში (ცხადია, თუ გავითვალისწინებთ იმას, რომ num არ გაცდეს შესაბამისი ტიპის საზღვრებს).

### აღნიშვნა:
 * ალბათ, შეამჩნევდით, რომ მიღებული ჯამის sumFormula-ცვლადში შენახვა არ არის საჭირო და შეგვეძლო პირდაპირ println() მეთოდში გადაგვეცა ის პლუსის შემდგომ, თუმცა იმისათვის, რომ კოდი უფრო წაკითხვადი იყოს, ვინახავთ sumFormula-ცვლადში, ამის შემდეგ, რომ დავხედოთ println()-მეთოდში ჩაწერილ არგუმენტს, ვხვდებით თუ რას აკეთებს ჩვენი პროგრამა, განსხვავებით იმ შემთხვევისგან, თუკი გვექნებოდა შემდეგი კოდი :
```java

println("Sum of natural numbers untill n is: " + (num*(num+1))/2);

```