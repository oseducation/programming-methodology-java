პრობლემა:

მომხმარებელს შემოყავს რიცხვი n და ჩვენ უნდა დავაბრუნოთ ფიბონაჩის მიმდევრობის მეენე წევრი

## ინფორმაციის წაკითხვა:

მომხმარებლის მიერ შემოყვანილ რიცხვებს ვკითხულობთ readInt() ის საშუალებით.

## პრობლემის გადაჭრის გზა:
მთავარი ნაწილია,დავწეროთ ფუნქცია, რომელიც მეენე წევრს პოულობს
ყოველი ენისთვის დაგვჭირდება წინა ორი წევრის ცოდნა რადგან
fn = fn_1 + fn_2 და თუ ვიცით წინა ორი წევრი მარტივად დავთვლით მესამესაც
გასათვალისწინებელია ბეის ქეისები, როგორეცაა პირველი და მეორე წევრი
ვინაიდან ამ წევრების საშუალებითაა აგებული მთელი მიმდევრობა  

## შესაძლო ამოხსნა:

ამ პრობლემის ამოხსნის რამდენიმე ვარიანტი არსებობს, ამ შემთხვევაში განვიხილოთ იტერაციული ამოხსნა
რომელშიც დაგვჭირდება მხოლოდ წინა ორი წევრის შენახვა

თავიდანვე ვითვალისწინებთ ბეის ქეისებს n = 1 და n = 2 და შესაბამის წევრს ვაბრუნებთ

ხოლო უფრო დიდი n-ებისთვის ვიწყებთ იტერაციას 
    ყოველ იტერაციაზე ვითვლით i-იურ წევრს წინა ორი წევრის საშუალებით 
    F_i = Fn_1 + Fn_2;
    იტერაციის ბოლოს კი ვაახლებთ ცვლადებს რაც მდგომარეობს შემდეგში
    // 0 1 2
    i = 3 ისთვის fn-1 = 1 და fn-2 = 0
    i = 4 ისთვის წინა წევრები უნდა იყვნენ 1 და 2
    ანუ fn-2 = fn-1 და fn-1 = fi
    ამ დროს ძალიან მნიშვნელოვანია თანმიმდევრობა
    რომ დაგვეწერა fn-1 = fi და fn-2 = fn-1 სრულიად სხვა შედეგს მივიღებდით

იტერაციის დასრულების შემდეგ პასუხი გვექნება ჩაწერილი fiში და დავაბრუნებთ ამ რიცხვს

შეიძლება ითქვას, რომ ალგორითმი არის კარგი, მაგრამ გააჩნია რამდენჯერ მოგვიწევს მისი გამოძახება
შეიძლება მომხმარებელს აინტერესებდეს 1 დან 45 მდე ფიბონაჩის ყველა წევრი
და ჩვენ თითოეული წევრის დათვლისას თავიდან მოგვიწევს ამ ფუნქციის გამოძახება
რაც ნიშნავს, რომ f(40)-ს დათვლის find_nth_fibonacci(40), find_nth_fibonacci(41)...find_nth_fibonacci(45)
რაც დროის მხრივ საკმაოდ წამგებიანია

## ამოხსნის სხვა ვარიანტი:
ამოცანა ასევე შესაძლებელია რეკურსიულად, რომელზეც კარგი იქნება ზედა შენიშვნას თუ გაითვალისწინებთ
და ალგორითმის მუშაობის დროს წრფივამდე დაიყვანთ

## შესაძლო გაუმჯობესება:
მატრიცების საშუალებით უკეთეს ამოხსნას შეგიძლიათ გაეცნოთ შემდეგ ბმულზე: https://web.mit.edu/18.06/www/Spring17/Fibonacci.pdf

## შესაძლო ხარვეზები:

* გასათვალისწინებელია ინტეჯერ ოვერფლოუ, თუ მომხმარებელი შემოგვიყვანს ისეთ ენს, რომლისთვისაც
fn ვეღარ თავსდება ინტეჯერების საზღვრებში ანუ გადააჭარბებს INT_MAX-ს

* გავითვალისწინოთ ისიც, თუ მომხმარებელი შემოიყვანს არადადებით რიცხვებს
ამ შემთხვევაში დავუბრუნოთ -1, ვინაიდან მიმდევრობა უბრალოდ არ არის განსაზღვრული უარყოფითი ენებისთვის


