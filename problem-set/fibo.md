პრობლემა:

მომხმარებელს შემოყავს რიცხვი n და ჩვენ უნდა დავაბრუნოთ ფიბონაჩის მიმდევრობის მეენე წევრი

## ინფორმაციის წაკითხვა:

სანამ მომხმარებელი არ შემოგვიყვანს სპეციალურ რიცხვს(sentinel-ს) მანამ მივცეთ
საშუალება, რომ შემოიყვანოს რიცხვი და ჩვენ დავუბეჭდავთ მეენე წევრს

მომხმარებლის მიერ შემოყვანილ რიცხვებს ვკითხულობთ readInt() ის საშუალებით

## პრობლემის გადაჭრის გზა:

* მთავარი ნაწილია,დავწეროთ ფუნქცია, რომელიც მეენე წევრს პოულობს
  ყოველი ენისთვის დაგვჭირდება წინა ორი წევრის ცოდნა რადგან
  fn = fn_1 + fn_2 და თუ ვიცით წინა ორი წევრი მარტივად დავთვლით მესამესაც
  გასათვალისწინებელია ბეის ქეისები, როგორეცაა პირველი და მეორე წევრი
  ვინაიდან ამ წევრების საშუალებითაა აგებული მთელი მიმდევრობა
  

## შესაძლო ამოხსნა:

ამ პრობლემის ამოხსნის რამდენიმე ვარიანტი არსებობს, ამ შემთხვევაში განვიხილოთ იტერაციული ამოხსნა
რომელშიც დაგვჭირდება მხოლოდ წინა ორი წევრის შენახვა

თავიდანვე ვითვალისწინებთ ბეის ქეისებს n = 1 და n = 2 და შესაბამის წევრს ვაბრუნებთ

ხოლო უფრო დიდი n-ებისთვის ვიწყებთ იტერაციას 
    ყოველ იტერაციაზე ვითვლით i-იურ წევრს წინა ორი წევრის საშუალებით 
    F_i = Fn_1 + Fn_2;
    იტერაციის ბოლოს კი ვაახლებთ ცვლადებს რაც მდგომარეობს შემდეგში
    // 0 1 2
    i = 3 ისთვის fn-1 = 1 და fn-2 = 0
    i = 4 ისთვის წინა წევრები უნდა იყვნენ 1 და 2
    ანუ fn-2 = fn-1 და fn-1 = fi
    ამ დროს ძალიან მნიშვნელოვანია თანმიმდევრობა
    რომ დაგვეწერა fn-1 = fi და fn-2 = fn-1 სრულიად სხვა შედეგს მივიღებდით

იტერაციის დასრულების შემდეგ პასუხი გვექნება ჩაწერილი fiში და დავაბრუნებთ ამ რიცხვს

ალგორითმის სირთულე არის O(n), რაც ნიშნავს, რომ წრფივ დროში ვპოულობთ მეენე წევრს
რაც შეეხება მეხსიერებას, მხოლოდ რამდენიმე ინტს ვიყენებეთ

შეიძლება ითქვას, რომ ალგორითმი არის კარგი, მაგრამ გააჩნია რამდენჯერ მოგვიწევს მისი გამოძახება
შეიძლება მომხმარებელს აინტერესებდეს 1 დან 45 მდე ფიბონაჩის ყველა წევრი
და ჩვენ თითოეული წევრის დათვლისას თავიდან მოგვიწევს ამ ფუნქციის გამოძახება
რაც ნიშნავს, რომ f(40)-ს დათვლის find_nth_fibonacci(40), find_nth_fibonacci(41)...find_nth_fibonacci(45)
რაც დროის მხრივ საკმაოდ წამგებიანია

## ამოხსნის სხვა ვარიანტი:
ამოცანა ასევე შესაძლებელია რეკურსიულად, რომელზეც კარგი იქნება ზედა შენიშვნას თუ გაითვალისწინებთ
და ალგორითმის მუშაობის დროს წრფივამდე დაიყვანთ

## შესაძლო გაუმჯობესება:
დამატებითი მეხსიერების ხარჯზე შეგვიძლია გადავჭრათ ეს პრობლემა
კერძოდ: გვქონდეს მასივი, რომლის იურ ინდექსზე შევინახავთ ფიბონაჩის მიმდევრობის
იურ წევრს და როდესაც მომხმარებელი შემოიყვანს რიცხვს, ჩვენ დავაბრუნებთ მასივში
ამ ინდექსზე მყოფ რიცხვს

## შესაძლო ხარვეზები:

* გასათვალისწინებელია ინტეჯერ ოვერფლოუ, თუ მომხმარებელი შემოგვიყვანს ისეთ ენს, რომლისთვისაც
fn ვეღარ თავსდება ინტეჯერების საზღვრებში ანუ გადააჭარბებს INT_MAX-ს

* გავითვალისწინოთ ისიც, თუ მომხმარებელი შემოიყვანს არადადებით რიცხვებს
ამ შემთხვევაში დავუბრუნოთ -1, ვინაიდან მიმდევრობა უბრალოდ არ არის განსაზღვრული უარყოფითი ენებისთვის


