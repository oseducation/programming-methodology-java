# Max2Numbers

პრობლემა:
```
კონსოლიდან შეგყვავს n და შემდეგ n ცალი მთელი რიცხვი, იპოვეთ და დაბეჭდეთ ამ
რიცხვებს შორის ორი მაქსიმალური რიცხვი.
```



## პრობლემის გადაჭრის გზა
პირველ რიგში ჩვენი პრობლემა დავყოთ ოთხ ნაწილად:
* მონაცემების შეტანა და შენახვა შესაბამის ცვლადებში.
* პირველი მაქსიმალური რიცხვის პოვნა.
* მეორე მაქსიმალური რიცხვის პოვნა.
* მიღებული შედეგების დაბეჭვდა.

---

### მონაცემების შეტანა

პირველ რიგში მოვთხოვოთ მომხმარებელს მოგვაწოდოს ინფორმაცია თუ რამდენი რიცხვი შემოჰყავს და შევინახოთ n-ში.
ამის შემდეგ შევქმნათ n ზომის მასივი რომელშიც შევინახავთ შემოტანილ რიცხვებს.
```java
private int[] readInput() {
	// 1. Read N
	int n = readInt("Input N: ");

	// 2. Read total of N integers
	int[] arr = new int[n];
	for (int i = 0; i < n; i++) {
		arr[i] = readInt("Input number #" + (i + 1) + ": ");
	}
	return arr;
}
```

---

### პირველი მაქსიმალური რიცხვის პოვნა
გადავუყვეთ მასივს და მოვძებნოთ მარტივი შედარებით ყველაზე დიდი რიცხვი. maxInd1 ში გვექნება მისი ინდექსი შენახული.
შემდეგ maxs მასივის პირველ ელემენტად ჩავწერთ maxInd1-ის შესაბამის ელემენტს.
```java
int maxInd1 = 0;
for (int i = 0; i < input.length; i++) {
	if (input[i] > input[maxInd1]) {
		maxInd1 = i;
	}
}
maxs[0] = input[maxInd1];
```

---

### მონაცემების შეტანა

მოვთხოვოთ მომხმარებელს მოგვაწოდოს ინფორმაცია, თუ რამდენი რიცხვი შემოჰყავს და შევინახოთ n-ში.
ამის შემდეგ შევქმნათ n ზომის მასივი, რომელშიც შევინახავთ შემოტანილ რიცხვებს.
```java
private int[] readInput() {
	// 1. Read N
	int n = readInt("Input N: ");

	// 2. Read total of N integers
	int[] arr = new int[n];
	for (int i = 0; i < n; i++) {
		arr[i] = readInt("Input number #" + (i + 1) + ": ");
	}
	return arr;
}
```

---

### მეორე მაქსიმალური რიცხვის პოვნა
თავდაპირველად ვახდენთ maxInd2 ისთვის ნებისმიერი ინდექსის მინიჭებას, ისეთის, რომ maxInd1-ს არ უდრიდეს.
შემდეგ იმავე ალგორითმით გადავუყვებით მასივს, თუმცა თან ვამოწმებთ რომელ ინდექსზეც ვდგავართ, ხომ არ უდრის პირველი მაქსიმალური რიცხვის ინდექს.
როდესაც ციკლი მუშაობას შეწყვეტს და maxInd2 ში იქნება მეორე მაქსიმალური ელემენტის ინდექსი, ეს ელემენტი დამახსოვრდება maxs მასივის მეორე ელემენტად.
```java
int maxInd2 = (maxInd1 + 1) % input.length;
for (int i = 0; i < input.length; i++) {
	if (input[i] > input[maxInd2] && i != maxInd1) {
		maxInd2 = i;
	}
}
maxs[1] = input[maxInd2];
```

---

### პასუხის დაბეჭვდა
maxs მასივში ჩვენ უკვე შენახული გვაქვს ჩვენთვის საჭირო ორი მაქსიმალური რიცხვი.
maxs[0] ში წერია ყველაზე მაქსიმალური, ხოლო maxs[1]-ში მეორე ყველაზე მაქსიმალური.
შეტანილი რიცხვებისგან რომ გამოვყოთ, პასუხის გამოტანამდე ცარიელი ხაზი დავაბეჭდინოთ.
```java
println();
println("1st Maximum: " + maxs[0]);
println("2nd Maximum: " + maxs[1]);
```

## ამოცანის ამოხსნის განსხვავებული ხერხი:
1. ამოცანის გადასაჭრელად შეგვიძლია დავასორტიროთ შემოტანილი მონაცემები და გამოვიტანოთ დასორტირებული მასივიდან ბოლო ორი ელემენტი.
თითქოს ერთი შეხედვით ამას უფრო მოკლე კოდი ექნება და უფრო მარტივი დასაწერი იქნება, თუმცა მუშაობის სისწრაფის თვალსაზრისით უფრო ნელი იქნება, ვიდრე ჩვენი ზემოთ დაწერილი ალგორითმი.

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
პირველ რიგში, მინდა მოგილოცოთ პროგრამის წარმატებით დასრულება და იმპლემენტაცია, თუმცა არსებობს დეტალი, რისი გათვალისწინებაც საკმაოდ მნიშვნელოვანია ამ ამოცანის გადაჭრისას.

1. შეცდომა იქნება თუ maxInd2-ს თავდაპირველად არ ავიღებთ maxInd1 -სგან განსხვავებულ ინდექს, რადგან ვთქვათ ისიც ავიღეთ 0 და ჩავთვალეთ, რომ მეორე ყველაზე დიდი ელემენტი ესაა. ეს კოდი არასწორად იმუშავებს იმ შემთხვევაში, თუ maxInd1-ც 0-ის ტოლი იყო, რადგან if ში აღარასდროს შევა და maxInd2 დარჩება ის მნიშვნელობა თავიდან რაც მივანიჭეთ, ამ შემთხვევაში 0.