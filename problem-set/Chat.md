# Chat

პრობლემა:
```
თქვენი ამოცანაა გრაფიკული პროგრამის საშუალებით გააკეთოთ ჩატი. ფანჯარაზე, SOUTH
რეგიონზე უნდა გქონდეთ ერთი ტექსტფილდი და ერთი ღილაკი ტექტით Enter.
ტექსტფილდში ტექსტის შეყვანის მერე Enter ჭილაკზე დაჭერით ტექსტი უნდა
იწერებოდეს(იხატებოდეს) კანვასზე ხოლო ტექსტფილდში კი ტექსტი იშლებოდეს. ხელახლა
ტექსტის შეყვანისას ახალი ტექსტი წინა ტექსტის ქვემოთ უნდა გამოცნდეს(როგორც ჩატში
ხდება ხოლმე. თუკი ტექსტი ჩაცდება ეკრანს არაუშავს.
```

## როგორ გადავჭრათ პრობლემა?
პირველ რიგში განვიხილოთ პრობლემის გადაჭრის ეტაპები:
1. ფანჯრის აწყობა.
2. ინფორმაციის მიღება.
3. კანვასის გამოსახულების განახლება.


### ფანრჯის აწყობა
პირობის თანახმად, ფანჯარის ქვედა მხარეს უნდა იყოს textfield და ღილაკი. ამ ორ ობიექტს, ისევე როგორც `Arraylist`-ს (შეტყობინებების  შესანახად), ვქმნით init-ის გარეთ, რადგან ჩვენს პროგრამაში ყველა მეთოდს ჰქონდეს წვდომა მათზე. (რატომ init და არა run? იხილეთ განმარტება ტექსტის ბოლოს)

დეკომპოზიციისთვის, ეს ეტაპი დავწეროთ `createFieldsAndVector` მეთოდში - დავაინიციალიზოთ textfield, ღილაკი, დავამატოთ ორივეზე actionListeners და გამოვსახოთ  ისინი ფანჯრის სამხრეთით. ასევე აქვე დავაინციალიზოთ ჩვენი პროგრამის მთავარი სტრუქტურა - `Arraylist`, სადაც ჩათის შეტყობინებებს  შევინახავთ:

```
	private void createFieldsAndVector() {
		txtField = new JTextField(20);
		add(txtField, SOUTH);
		txtField.addActionListener(this);
		
		sendBtn = new JButton("Enter");
		add(sendBtn, SOUTH);
		sendBtn.addActionListener(this);
		
		chat = new ArrayList<>();
	}
```

### ინფორმაციის მიღება
მომხმარებლის გაგზავნილი შეტყობინებები ჩვენმა პროგრამამ რომელიმე სტრუქტურაში უნდა შეინახოს, რათა კანვასზე გამოვსახოთ. პირველ რიგში, როდესაც მომხმარებელი ღილაკს ან კლავიატურაზე Enter-ს დააჭერს, ჩვენი პროგრამა უნდა მიხვდეს, რომ textfield-ში ჩაწერილი `String`-ის მნიშვნელობა წაიკითხოს. ამისათვის ვიყენებთ `ActionListener`-ებს, რომლებიც წინა ეტაპზე შევქმენით ორივე ელემენტისთვის.

ActionListener-ების გამოყენებას სპეციალური მეთოდით - `actionPerformed`-ით შევქმნით, რომელსაც  `ActionEvent`-ს გადავცემთ. გაითვალისწინეთ მეთოდი `public` ტიპის უნდა იყოს:

```
	public void actionPerformed(ActionEvent e) {}
```

`actionPerformed` მეთოდს პროგრამა მაშინ გამოიძახებს, თუ მომხმარებელმა ის ელემენტი გამოიყენა, რომელზეც `actionListener` გვაქვს დამატებული. ჩვენ ეს პირველ ეტაპზე `createFieldsAndVector` მეთოდში განვახორციელეთ. `actionPerformed`-მა  textfield-ში ჩაწერილი ტექსტი უნდა წაიკითოს - ამას `getText()`-ით მოახერხებს, შეამოწმოს არის თუ არა იგი ცარიელი მნიშვნელობის (ჩავთვალოთ, რომ ცარიელი შეტყობინების დამატება ჩათში არ გვსურს) და შეტყობინების არსებობის შემთხვევაში `ArrayList`-ში ჩაწეროს:

```
	public void actionPerformed(ActionEvent e) {
		String input = txtField.getText();
		txtField.setText("");
		if(input != "") chat.add(input);
	}
```

### კანვასის  გამოსახულების განახლება
ახლა, როცა `ArrayList`-ში ახალი შეტყობინება დავამატეთ, კანვასიც განვაახლოთ. ამისათვის  ახალი მეთოდის, `update`,  დაწერა დაგვჭირდება, რომელსაც `actionPerformed`-ის ბოლოს გამოვიძახებთ, იმ შემთხვევაში თუ გადმოცემული შეტყობინება ცარიელი ტექსტი არაა. ბოლო პირობის არგათვალისწინება პროგრამის მუშაობას ხელს არ შეუშლის, მაგრამ უმჯობესია მეთოდი მხოლოდ  მაშინ გამოვიძახოთ, როდესაც გვჭირდება. განახლებული `actionPerformed` ასე გამოიყურება:

```
	public void actionPerformed(ActionEvent e) {
			String input = txtField.getText();
			txtField.setText("");
			if(input != "") {
				chat.add(input);
				update(); // <------------------
			}
	}
```

კანვასზე შეტყობინებებს `GLabel`-ებით გამოვსახავთ. ობიექტს 3 პარამეტრი უნდა გადავცეთ - x და y კოორდინატი, `String` ტიპის ცვლადი, სადაც შეტყობინების მნიშვნელობა ინახება. x კოორდინატი თითოეული `GLabel`-სთვის იგივეა, ამიტომ იგი კონსტანტად შევინახოთ კოდის დასაწყისში -  `private static final int X = 20;`, ისევე როგორც ტექსტის დაშორება ქვედა კიდიდან (`BOTTOMSPACE`) და თითოეულ შეტყობინებას შორის დაშორება (`GAP`). შეტყობინებებს შორის რაც იცვლება არის y კოორდინატი და ტექსტი მნიშვნებლობა, რომელიც `ArrayList`-ში გვაქვს შენახული.

თითოეული შეტყობინებისთვის ამ პარამეტრების გადასაცემად for ციკლი გამოვიყენოთ, რომელიც ArrayList-ს გადაუყვება: `for(int i = chat.size() - 1; i >= 0; i--)`.
ჩვენი for ციკლი `ArrayList`-ს ბოლოს დამატებული ელემენტიდან, პირველად დამატებულ ელემენტამდე გადაუყვება და მათზე წვდომას მოგვცემს. ამ პრინციპს ამოცანის პირობის შესასრულებლად ვიყენებთ, ახალი შეტყობინება სხვა შეტყობინებების ქვევით უნდა იყოს. for loop-ის დახმარებით  შევძლებთ `GLabel`-ს გადავცეთ  `ArrayList`-ის კონკრეტული ელემენტი და ყოველ ჯერზე ვცვალოთ y კოორდინატი (შევინახოთ იგი for ციკლის გარეთ და for-ის ყოველ იტერაციაზე ვაკლოთ `GAP`-ის მნიშვნელობა):

```
	private void update() {	
		int y = getHeight() - BOTTOMSPACE;
		for (int i = chat.size() - 1; i >= 0; i--) {
			String message = chat.get(i);
			add(new GLabel(message, X, y));
			y -= GAP;
		}
	}
```

update() თითქმის სრულყოფილია. ახალი შეტყობინების მიღებისას update მეთოდი კანვასს, რომელზეც შესაძლოა უკვე გვქონდეს გამოსახული ჩათი, ახალ ვერსიას თავზე გადააწერს. ამის გამოსწორება  მეთოდის გამოძახებისას კანვასის გასუფთავებით შეგვიძლია. removeAll() ბრძანება, რომელიც ზუსტად ამ სამუშაოს ასრულებს (კანვასიდან შლის ყველა ელემენტს) update მეთოდის დასაწყისში დავამატოთ:

```
	private void update() {	
		removeAll(); // <--------
		int y = getHeight() - BOTTOMSPACE;
		for (int i = chat.size() - 1; i >= 0; i--) {
			String message = chat.get(i);
			add(new GLabel(message, X, y));
			y -= GAP;
		}
	}
```

#### init vs run - რატომ გვიწერია ჩვენს კოდში init მეთოდი? სად არის run?
როგორც `run` ასევე `init` რეალურად Java-ში არ გვხვდება. ეს მეთოდები პროგრამირების მეთოდოლოგიების კურსის ფარგლებშია შექმნილი  სტენფორდის უნივესიტეტის მიერ. ორივე მეთოდს შეუძლია შეითავსოს ერთმანეთის თვისებები , როდესაც მხოლოდ ერთ-ერთს ვწერთ. როდესაც კოდს გაუშვებთ პროგრამა ჯერ `init`-ში შედის და იქ დაწერილ კოდს კითხულობს, მხოლოდ  ამის შემდეგ გადადის `run` მეთოდზე.
ჩვენს ამოცანაში `run` საერთოდ არ დაგვჭირდა, რადგანაც პროგრამა არაფერს არ აკეთებს თუ მომხარებელმა არ შეიყვანა ტექსტი, რის შემთხვევაშიც `actionPerformed` ეშვება. 

მაშასადამე, შეგიძლიათ `init`-ში პროგრამის გარემო დაწეროთ (დააინიციალიზოთ ობიექტები, ღილაკები, `actionListener`-ები და ა.შ), რომელიც `run` მეთოდის გაშვებამდე შეიქმნება პროგრამაში.
