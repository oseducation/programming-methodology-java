# InfinitelyMovingBall

პრობლემა:
```
წინა ამოცანის გაგრძელება, დაამატეთ ვერტიკალური კედლებიდან ასხლეტვა. ანუ ბურთი
მოძრაობს მარცხენა კედლიდან მარჯვნივ. როგორც კი მარჯვენა კედელს დაეტაკება იმავე
სიჩქარით უნდა გააგრძელოს მოძრაობა მაჯვენა კედლიდან მარცხნივ. როგორც კი მარცხენა
კედელს დაეტაკება უნდა გააგრძელოს მარჯვნივ და ა.შ. უსასრულოდ.
```

## პრობლემის გადაჭრის გზა
პირველ რიგში ჩვენი პრობლემა დავყოთ ორ ძირითად ნაწილად:
* თავდაპირველად შევქმნათ ბურთი
* ავამოძრაოთ ბურთი უსუსრულოდ
---

### ბურთის შექმნა
უკვე შექმნილი ბურთის instance-ის ინიციალიზაცია გავაკეთოთ ახალ მეთოდში, სადაც გამოვთვლით ბურთის კოორდინატებს 
და კანვასზე დავამატებთ `RADIUS` კონსტატის ზომის რადიუსის მქონე ბურთს.

### ბურთის უსასრულოდ ამოძრავება
ახლა, როდესაც ბურთი შექმნილია, შეგვიძლია ვიზრუნოთ მის უსასრულოდ ამოძრავებაზე, ამისთვის გამოვიყენებთ `move` 
მეთოდს. როდესაც მოძრავი ბურთი მარცხენა ან მარჯვენა საზღვარს გაცდება, მისი სიჩქარე -1-ზე გავამრავლოთ, 
რათა მოძრაობის მიმართულება შეიცვალოს ბურთმა. 

შესაბამისად, მივიღებთ კოდს:
```java
double ballDx = VELOCITY;
while (true) {
    ball.move(ballDx, 0);

    if (ball.getX() <= 0 || ball.getX() >= getWidth() - 2 * RADIUS) { // ბურთმა მიაღწია საზღვრებს
        ballDx *= -1;
    }
    pause(DELAY);
}
```

---

## შესაძლო ხარვეზები ამოხსნის იმპლემენტაციისას
- იმ შემთხვევაში, თუ სიჩქარე დიდი იქნება, შესაძლოა ბურთი ფანჯრის საზღვრებს გაცდეს. ამის გამო, 
საჭიროა ყოველ ჯერზე ბურთის ამოძრავებისას გამოვითვალოთ დარჩენილი პიქსელების რაოდენობა საზღვრამდე
და გადავიდეთ იმ რაოდენობის პიქსელით, რომ ბურთი საზღვარს არ ცდებოდეს.
შესაბამისად, პროგრამას უნდა ჩაემატოს კოდის ეს ნაწილი:
```java
double currDx;
if (ballDx > 0) {   // ბურთი მოძრაობს მარჯვნივ 
    currDx = Math.min(ballDx, getWidth() - ball.getX() - 2 * RADIUS);
} else {            // ბურთი მოძრაობს მარცხნივ
    currDx = Math.max(ballDx, -ball.getX());
}
```
- `while` ციკლში არ უნდა დაგვავიწყდეს `pause`-ს დამატება, წინააღმდეგ შემთხვევაში ბურთი 
წინა ლოკაციიდან "გადახტება" ეგრევე შემდეგ ლოკაციაზე და პროგრამას არ ექნება ანიმაციის სახე.